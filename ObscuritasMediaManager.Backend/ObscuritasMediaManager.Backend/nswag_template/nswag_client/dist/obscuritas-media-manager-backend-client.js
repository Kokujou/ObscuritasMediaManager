import * as tslib_1 from "tslib";
/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.13.2.0 (NJsonSchema v10.5.2.0 (Newtonsoft.Json v12.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming
import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';
import * as i0 from "@angular/core";
import * as i1 from "@angular/common/http";
export var OBSCURITAS_MEDIA_MANAGER_BACKEND_API_BASE_URL = new InjectionToken('OBSCURITAS_MEDIA_MANAGER_BACKEND_API_BASE_URL');
var FileClient = /** @class */ (function () {
    function FileClient(http, baseUrl) {
        this.jsonParseReviver = undefined;
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }
    FileClient.prototype.getVideo = function (videoPath) {
        var _this = this;
        var url_ = this.baseUrl + "/api/File/video?";
        if (videoPath !== undefined && videoPath !== null)
            url_ += "videoPath=" + encodeURIComponent("" + videoPath) + "&";
        url_ = url_.replace(/[?&]$/, "");
        var options_ = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };
        return this.http.request("get", url_, options_).pipe(_observableMergeMap(function (response_) {
            return _this.processGetVideo(response_);
        })).pipe(_observableCatch(function (response_) {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return _this.processGetVideo(response_);
                }
                catch (e) {
                    return _observableThrow(e);
                }
            }
            else
                return _observableThrow(response_);
        }));
    };
    FileClient.prototype.processGetVideo = function (response) {
        var status = response.status;
        var responseBlob = response instanceof HttpResponse ? response.body :
            response.error instanceof Blob ? response.error : undefined;
        var _headers = {};
        if (response.headers) {
            for (var _i = 0, _a = response.headers.keys(); _i < _a.length; _i++) {
                var key = _a[_i];
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200 || status === 206) {
            var contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            var fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            var fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob, status: status, headers: _headers });
        }
        else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(function (_responseText) {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null);
    };
    FileClient.prototype.getAudio = function (audioPath) {
        var _this = this;
        var url_ = this.baseUrl + "/api/File/audio?";
        if (audioPath !== undefined && audioPath !== null)
            url_ += "audioPath=" + encodeURIComponent("" + audioPath) + "&";
        url_ = url_.replace(/[?&]$/, "");
        var options_ = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };
        return this.http.request("get", url_, options_).pipe(_observableMergeMap(function (response_) {
            return _this.processGetAudio(response_);
        })).pipe(_observableCatch(function (response_) {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return _this.processGetAudio(response_);
                }
                catch (e) {
                    return _observableThrow(e);
                }
            }
            else
                return _observableThrow(response_);
        }));
    };
    FileClient.prototype.processGetAudio = function (response) {
        var status = response.status;
        var responseBlob = response instanceof HttpResponse ? response.body :
            response.error instanceof Blob ? response.error : undefined;
        var _headers = {};
        if (response.headers) {
            for (var _i = 0, _a = response.headers.keys(); _i < _a.length; _i++) {
                var key = _a[_i];
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200 || status === 206) {
            var contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            var fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            var fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob, status: status, headers: _headers });
        }
        else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(function (_responseText) {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null);
    };
    FileClient.prototype.validate = function (fileUrls) {
        var _this = this;
        var url_ = this.baseUrl + "/api/File/validate-files";
        url_ = url_.replace(/[?&]$/, "");
        var content_ = JSON.stringify(fileUrls);
        var options_ = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };
        return this.http.request("post", url_, options_).pipe(_observableMergeMap(function (response_) {
            return _this.processValidate(response_);
        })).pipe(_observableCatch(function (response_) {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return _this.processValidate(response_);
                }
                catch (e) {
                    return _observableThrow(e);
                }
            }
            else
                return _observableThrow(response_);
        }));
    };
    FileClient.prototype.processValidate = function (response) {
        var status = response.status;
        var responseBlob = response instanceof HttpResponse ? response.body :
            response.error instanceof Blob ? response.error : undefined;
        var _headers = {};
        if (response.headers) {
            for (var _i = 0, _a = response.headers.keys(); _i < _a.length; _i++) {
                var key = _a[_i];
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200 || status === 206) {
            var contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            var fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            var fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob, status: status, headers: _headers });
        }
        else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(function (_responseText) {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null);
    };
    FileClient.ngInjectableDef = i0.ɵɵdefineInjectable({ factory: function FileClient_Factory() { return new FileClient(i0.ɵɵinject(i1.HttpClient), i0.ɵɵinject(OBSCURITAS_MEDIA_MANAGER_BACKEND_API_BASE_URL, 8)); }, token: FileClient, providedIn: "root" });
    FileClient = tslib_1.__decorate([
        Injectable({
            providedIn: 'root'
        }),
        tslib_1.__param(0, Inject(HttpClient)), tslib_1.__param(1, Optional()), tslib_1.__param(1, Inject(OBSCURITAS_MEDIA_MANAGER_BACKEND_API_BASE_URL)),
        tslib_1.__metadata("design:paramtypes", [HttpClient, String])
    ], FileClient);
    return FileClient;
}());
export { FileClient };
var GenreClient = /** @class */ (function () {
    function GenreClient(http, baseUrl) {
        this.jsonParseReviver = undefined;
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }
    GenreClient.prototype.getAll = function () {
        var _this = this;
        var url_ = this.baseUrl + "/api/Genre";
        url_ = url_.replace(/[?&]$/, "");
        var options_ = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };
        return this.http.request("get", url_, options_).pipe(_observableMergeMap(function (response_) {
            return _this.processGetAll(response_);
        })).pipe(_observableCatch(function (response_) {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return _this.processGetAll(response_);
                }
                catch (e) {
                    return _observableThrow(e);
                }
            }
            else
                return _observableThrow(response_);
        }));
    };
    GenreClient.prototype.processGetAll = function (response) {
        var status = response.status;
        var responseBlob = response instanceof HttpResponse ? response.body :
            response.error instanceof Blob ? response.error : undefined;
        var _headers = {};
        if (response.headers) {
            for (var _i = 0, _a = response.headers.keys(); _i < _a.length; _i++) {
                var key = _a[_i];
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200 || status === 206) {
            var contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            var fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            var fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob, status: status, headers: _headers });
        }
        else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(function (_responseText) {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null);
    };
    GenreClient.ngInjectableDef = i0.ɵɵdefineInjectable({ factory: function GenreClient_Factory() { return new GenreClient(i0.ɵɵinject(i1.HttpClient), i0.ɵɵinject(OBSCURITAS_MEDIA_MANAGER_BACKEND_API_BASE_URL, 8)); }, token: GenreClient, providedIn: "root" });
    GenreClient = tslib_1.__decorate([
        Injectable({
            providedIn: 'root'
        }),
        tslib_1.__param(0, Inject(HttpClient)), tslib_1.__param(1, Optional()), tslib_1.__param(1, Inject(OBSCURITAS_MEDIA_MANAGER_BACKEND_API_BASE_URL)),
        tslib_1.__metadata("design:paramtypes", [HttpClient, String])
    ], GenreClient);
    return GenreClient;
}());
export { GenreClient };
var MediaClient = /** @class */ (function () {
    function MediaClient(http, baseUrl) {
        this.jsonParseReviver = undefined;
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }
    MediaClient.prototype.get = function (guid) {
        var _this = this;
        var url_ = this.baseUrl + "/api/Media/{guid}";
        if (guid === undefined || guid === null)
            throw new Error("The parameter 'guid' must be defined.");
        url_ = url_.replace("{guid}", encodeURIComponent("" + guid));
        url_ = url_.replace(/[?&]$/, "");
        var options_ = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };
        return this.http.request("get", url_, options_).pipe(_observableMergeMap(function (response_) {
            return _this.processGet(response_);
        })).pipe(_observableCatch(function (response_) {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return _this.processGet(response_);
                }
                catch (e) {
                    return _observableThrow(e);
                }
            }
            else
                return _observableThrow(response_);
        }));
    };
    MediaClient.prototype.processGet = function (response) {
        var status = response.status;
        var responseBlob = response instanceof HttpResponse ? response.body :
            response.error instanceof Blob ? response.error : undefined;
        var _headers = {};
        if (response.headers) {
            for (var _i = 0, _a = response.headers.keys(); _i < _a.length; _i++) {
                var key = _a[_i];
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200 || status === 206) {
            var contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            var fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            var fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob, status: status, headers: _headers });
        }
        else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(function (_responseText) {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null);
    };
    MediaClient.prototype.getAll = function (type) {
        var _this = this;
        var url_ = this.baseUrl + "/api/Media?";
        if (type !== undefined && type !== null)
            url_ += "type=" + encodeURIComponent("" + type) + "&";
        url_ = url_.replace(/[?&]$/, "");
        var options_ = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };
        return this.http.request("get", url_, options_).pipe(_observableMergeMap(function (response_) {
            return _this.processGetAll(response_);
        })).pipe(_observableCatch(function (response_) {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return _this.processGetAll(response_);
                }
                catch (e) {
                    return _observableThrow(e);
                }
            }
            else
                return _observableThrow(response_);
        }));
    };
    MediaClient.prototype.processGetAll = function (response) {
        var status = response.status;
        var responseBlob = response instanceof HttpResponse ? response.body :
            response.error instanceof Blob ? response.error : undefined;
        var _headers = {};
        if (response.headers) {
            for (var _i = 0, _a = response.headers.keys(); _i < _a.length; _i++) {
                var key = _a[_i];
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200 || status === 206) {
            var contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            var fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            var fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob, status: status, headers: _headers });
        }
        else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(function (_responseText) {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null);
    };
    MediaClient.prototype.batchPostStreamingEntries = function (media) {
        var _this = this;
        var url_ = this.baseUrl + "/api/Media";
        url_ = url_.replace(/[?&]$/, "");
        var content_ = JSON.stringify(media);
        var options_ = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };
        return this.http.request("post", url_, options_).pipe(_observableMergeMap(function (response_) {
            return _this.processBatchPostStreamingEntries(response_);
        })).pipe(_observableCatch(function (response_) {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return _this.processBatchPostStreamingEntries(response_);
                }
                catch (e) {
                    return _observableThrow(e);
                }
            }
            else
                return _observableThrow(response_);
        }));
    };
    MediaClient.prototype.processBatchPostStreamingEntries = function (response) {
        var status = response.status;
        var responseBlob = response instanceof HttpResponse ? response.body :
            response.error instanceof Blob ? response.error : undefined;
        var _headers = {};
        if (response.headers) {
            for (var _i = 0, _a = response.headers.keys(); _i < _a.length; _i++) {
                var key = _a[_i];
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200 || status === 206) {
            var contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            var fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            var fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob, status: status, headers: _headers });
        }
        else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(function (_responseText) {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null);
    };
    MediaClient.prototype.updateMedia = function (media) {
        var _this = this;
        var url_ = this.baseUrl + "/api/Media";
        url_ = url_.replace(/[?&]$/, "");
        var content_ = JSON.stringify(media);
        var options_ = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };
        return this.http.request("put", url_, options_).pipe(_observableMergeMap(function (response_) {
            return _this.processUpdateMedia(response_);
        })).pipe(_observableCatch(function (response_) {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return _this.processUpdateMedia(response_);
                }
                catch (e) {
                    return _observableThrow(e);
                }
            }
            else
                return _observableThrow(response_);
        }));
    };
    MediaClient.prototype.processUpdateMedia = function (response) {
        var status = response.status;
        var responseBlob = response instanceof HttpResponse ? response.body :
            response.error instanceof Blob ? response.error : undefined;
        var _headers = {};
        if (response.headers) {
            for (var _i = 0, _a = response.headers.keys(); _i < _a.length; _i++) {
                var key = _a[_i];
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200 || status === 206) {
            var contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            var fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            var fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob, status: status, headers: _headers });
        }
        else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(function (_responseText) {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null);
    };
    MediaClient.prototype.addMediaImage = function (request, guid) {
        var _this = this;
        var url_ = this.baseUrl + "/api/Media/{guid}/image";
        if (guid === undefined || guid === null)
            throw new Error("The parameter 'guid' must be defined.");
        url_ = url_.replace("{guid}", encodeURIComponent("" + guid));
        url_ = url_.replace(/[?&]$/, "");
        var content_ = JSON.stringify(request);
        var options_ = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };
        return this.http.request("put", url_, options_).pipe(_observableMergeMap(function (response_) {
            return _this.processAddMediaImage(response_);
        })).pipe(_observableCatch(function (response_) {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return _this.processAddMediaImage(response_);
                }
                catch (e) {
                    return _observableThrow(e);
                }
            }
            else
                return _observableThrow(response_);
        }));
    };
    MediaClient.prototype.processAddMediaImage = function (response) {
        var status = response.status;
        var responseBlob = response instanceof HttpResponse ? response.body :
            response.error instanceof Blob ? response.error : undefined;
        var _headers = {};
        if (response.headers) {
            for (var _i = 0, _a = response.headers.keys(); _i < _a.length; _i++) {
                var key = _a[_i];
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200 || status === 206) {
            var contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            var fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            var fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob, status: status, headers: _headers });
        }
        else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(function (_responseText) {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null);
    };
    MediaClient.prototype.deleteMediaImage = function (guid) {
        var _this = this;
        var url_ = this.baseUrl + "/api/Media/{guid}/image";
        if (guid === undefined || guid === null)
            throw new Error("The parameter 'guid' must be defined.");
        url_ = url_.replace("{guid}", encodeURIComponent("" + guid));
        url_ = url_.replace(/[?&]$/, "");
        var options_ = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };
        return this.http.request("delete", url_, options_).pipe(_observableMergeMap(function (response_) {
            return _this.processDeleteMediaImage(response_);
        })).pipe(_observableCatch(function (response_) {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return _this.processDeleteMediaImage(response_);
                }
                catch (e) {
                    return _observableThrow(e);
                }
            }
            else
                return _observableThrow(response_);
        }));
    };
    MediaClient.prototype.processDeleteMediaImage = function (response) {
        var status = response.status;
        var responseBlob = response instanceof HttpResponse ? response.body :
            response.error instanceof Blob ? response.error : undefined;
        var _headers = {};
        if (response.headers) {
            for (var _i = 0, _a = response.headers.keys(); _i < _a.length; _i++) {
                var key = _a[_i];
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200 || status === 206) {
            var contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            var fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            var fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob, status: status, headers: _headers });
        }
        else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(function (_responseText) {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null);
    };
    MediaClient.ngInjectableDef = i0.ɵɵdefineInjectable({ factory: function MediaClient_Factory() { return new MediaClient(i0.ɵɵinject(i1.HttpClient), i0.ɵɵinject(OBSCURITAS_MEDIA_MANAGER_BACKEND_API_BASE_URL, 8)); }, token: MediaClient, providedIn: "root" });
    MediaClient = tslib_1.__decorate([
        Injectable({
            providedIn: 'root'
        }),
        tslib_1.__param(0, Inject(HttpClient)), tslib_1.__param(1, Optional()), tslib_1.__param(1, Inject(OBSCURITAS_MEDIA_MANAGER_BACKEND_API_BASE_URL)),
        tslib_1.__metadata("design:paramtypes", [HttpClient, String])
    ], MediaClient);
    return MediaClient;
}());
export { MediaClient };
var MusicClient = /** @class */ (function () {
    function MusicClient(http, baseUrl) {
        this.jsonParseReviver = undefined;
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }
    MusicClient.prototype.batchCreateMusicTracks = function (tracks) {
        var _this = this;
        var url_ = this.baseUrl + "/api/Music";
        url_ = url_.replace(/[?&]$/, "");
        var content_ = JSON.stringify(tracks);
        var options_ = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };
        return this.http.request("post", url_, options_).pipe(_observableMergeMap(function (response_) {
            return _this.processBatchCreateMusicTracks(response_);
        })).pipe(_observableCatch(function (response_) {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return _this.processBatchCreateMusicTracks(response_);
                }
                catch (e) {
                    return _observableThrow(e);
                }
            }
            else
                return _observableThrow(response_);
        }));
    };
    MusicClient.prototype.processBatchCreateMusicTracks = function (response) {
        var status = response.status;
        var responseBlob = response instanceof HttpResponse ? response.body :
            response.error instanceof Blob ? response.error : undefined;
        var _headers = {};
        if (response.headers) {
            for (var _i = 0, _a = response.headers.keys(); _i < _a.length; _i++) {
                var key = _a[_i];
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200 || status === 206) {
            var contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            var fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            var fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob, status: status, headers: _headers });
        }
        else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(function (_responseText) {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null);
    };
    MusicClient.prototype.getAll = function () {
        var _this = this;
        var url_ = this.baseUrl + "/api/Music";
        url_ = url_.replace(/[?&]$/, "");
        var options_ = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };
        return this.http.request("get", url_, options_).pipe(_observableMergeMap(function (response_) {
            return _this.processGetAll(response_);
        })).pipe(_observableCatch(function (response_) {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return _this.processGetAll(response_);
                }
                catch (e) {
                    return _observableThrow(e);
                }
            }
            else
                return _observableThrow(response_);
        }));
    };
    MusicClient.prototype.processGetAll = function (response) {
        var _this = this;
        var status = response.status;
        var responseBlob = response instanceof HttpResponse ? response.body :
            response.error instanceof Blob ? response.error : undefined;
        var _headers = {};
        if (response.headers) {
            for (var _i = 0, _a = response.headers.keys(); _i < _a.length; _i++) {
                var key = _a[_i];
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(function (_responseText) {
                var result200 = null;
                var resultData200 = _responseText === "" ? null : JSON.parse(_responseText, _this.jsonParseReviver);
                if (Array.isArray(resultData200)) {
                    result200 = [];
                    for (var _i = 0, resultData200_1 = resultData200; _i < resultData200_1.length; _i++) {
                        var item = resultData200_1[_i];
                        result200.push(MusicModel.fromJS(item));
                    }
                }
                else {
                    result200 = null;
                }
                return _observableOf(result200);
            }));
        }
        else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(function (_responseText) {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null);
    };
    MusicClient.prototype.get = function (guid) {
        var _this = this;
        var url_ = this.baseUrl + "/api/Music/{guid}";
        if (guid === undefined || guid === null)
            throw new Error("The parameter 'guid' must be defined.");
        url_ = url_.replace("{guid}", encodeURIComponent("" + guid));
        url_ = url_.replace(/[?&]$/, "");
        var options_ = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };
        return this.http.request("get", url_, options_).pipe(_observableMergeMap(function (response_) {
            return _this.processGet(response_);
        })).pipe(_observableCatch(function (response_) {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return _this.processGet(response_);
                }
                catch (e) {
                    return _observableThrow(e);
                }
            }
            else
                return _observableThrow(response_);
        }));
    };
    MusicClient.prototype.processGet = function (response) {
        var _this = this;
        var status = response.status;
        var responseBlob = response instanceof HttpResponse ? response.body :
            response.error instanceof Blob ? response.error : undefined;
        var _headers = {};
        if (response.headers) {
            for (var _i = 0, _a = response.headers.keys(); _i < _a.length; _i++) {
                var key = _a[_i];
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(function (_responseText) {
                var result200 = null;
                var resultData200 = _responseText === "" ? null : JSON.parse(_responseText, _this.jsonParseReviver);
                result200 = MusicModel.fromJS(resultData200);
                return _observableOf(result200);
            }));
        }
        else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(function (_responseText) {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null);
    };
    MusicClient.prototype.getInstruments = function () {
        var _this = this;
        var url_ = this.baseUrl + "/api/Music/instruments";
        url_ = url_.replace(/[?&]$/, "");
        var options_ = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };
        return this.http.request("get", url_, options_).pipe(_observableMergeMap(function (response_) {
            return _this.processGetInstruments(response_);
        })).pipe(_observableCatch(function (response_) {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return _this.processGetInstruments(response_);
                }
                catch (e) {
                    return _observableThrow(e);
                }
            }
            else
                return _observableThrow(response_);
        }));
    };
    MusicClient.prototype.processGetInstruments = function (response) {
        var _this = this;
        var status = response.status;
        var responseBlob = response instanceof HttpResponse ? response.body :
            response.error instanceof Blob ? response.error : undefined;
        var _headers = {};
        if (response.headers) {
            for (var _i = 0, _a = response.headers.keys(); _i < _a.length; _i++) {
                var key = _a[_i];
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(function (_responseText) {
                var result200 = null;
                var resultData200 = _responseText === "" ? null : JSON.parse(_responseText, _this.jsonParseReviver);
                if (Array.isArray(resultData200)) {
                    result200 = [];
                    for (var _i = 0, resultData200_2 = resultData200; _i < resultData200_2.length; _i++) {
                        var item = resultData200_2[_i];
                        result200.push(InstrumentModel.fromJS(item));
                    }
                }
                else {
                    result200 = null;
                }
                return _observableOf(result200);
            }));
        }
        else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(function (_responseText) {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null);
    };
    MusicClient.prototype.update = function (id, updateRequest) {
        var _this = this;
        var url_ = this.baseUrl + "/api/Music/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");
        var content_ = JSON.stringify(updateRequest);
        var options_ = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };
        return this.http.request("put", url_, options_).pipe(_observableMergeMap(function (response_) {
            return _this.processUpdate(response_);
        })).pipe(_observableCatch(function (response_) {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return _this.processUpdate(response_);
                }
                catch (e) {
                    return _observableThrow(e);
                }
            }
            else
                return _observableThrow(response_);
        }));
    };
    MusicClient.prototype.processUpdate = function (response) {
        var status = response.status;
        var responseBlob = response instanceof HttpResponse ? response.body :
            response.error instanceof Blob ? response.error : undefined;
        var _headers = {};
        if (response.headers) {
            for (var _i = 0, _a = response.headers.keys(); _i < _a.length; _i++) {
                var key = _a[_i];
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200 || status === 206) {
            var contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            var fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            var fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob, status: status, headers: _headers });
        }
        else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(function (_responseText) {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null);
    };
    MusicClient.ngInjectableDef = i0.ɵɵdefineInjectable({ factory: function MusicClient_Factory() { return new MusicClient(i0.ɵɵinject(i1.HttpClient), i0.ɵɵinject(OBSCURITAS_MEDIA_MANAGER_BACKEND_API_BASE_URL, 8)); }, token: MusicClient, providedIn: "root" });
    MusicClient = tslib_1.__decorate([
        Injectable({
            providedIn: 'root'
        }),
        tslib_1.__param(0, Inject(HttpClient)), tslib_1.__param(1, Optional()), tslib_1.__param(1, Inject(OBSCURITAS_MEDIA_MANAGER_BACKEND_API_BASE_URL)),
        tslib_1.__metadata("design:paramtypes", [HttpClient, String])
    ], MusicClient);
    return MusicClient;
}());
export { MusicClient };
var PlaylistClient = /** @class */ (function () {
    function PlaylistClient(http, baseUrl) {
        this.jsonParseReviver = undefined;
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }
    PlaylistClient.prototype.createTemporaryPlaylist = function (entries) {
        var _this = this;
        var url_ = this.baseUrl + "/api/Playlist/temp";
        url_ = url_.replace(/[?&]$/, "");
        var content_ = JSON.stringify(entries);
        var options_ = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };
        return this.http.request("post", url_, options_).pipe(_observableMergeMap(function (response_) {
            return _this.processCreateTemporaryPlaylist(response_);
        })).pipe(_observableCatch(function (response_) {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return _this.processCreateTemporaryPlaylist(response_);
                }
                catch (e) {
                    return _observableThrow(e);
                }
            }
            else
                return _observableThrow(response_);
        }));
    };
    PlaylistClient.prototype.processCreateTemporaryPlaylist = function (response) {
        var status = response.status;
        var responseBlob = response instanceof HttpResponse ? response.body :
            response.error instanceof Blob ? response.error : undefined;
        var _headers = {};
        if (response.headers) {
            for (var _i = 0, _a = response.headers.keys(); _i < _a.length; _i++) {
                var key = _a[_i];
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200 || status === 206) {
            var contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            var fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            var fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob, status: status, headers: _headers });
        }
        else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(function (_responseText) {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null);
    };
    PlaylistClient.prototype.getTemporaryPlaylist = function (guid) {
        var _this = this;
        var url_ = this.baseUrl + "/api/Playlist/temp/{guid}";
        if (guid === undefined || guid === null)
            throw new Error("The parameter 'guid' must be defined.");
        url_ = url_.replace("{guid}", encodeURIComponent("" + guid));
        url_ = url_.replace(/[?&]$/, "");
        var options_ = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };
        return this.http.request("get", url_, options_).pipe(_observableMergeMap(function (response_) {
            return _this.processGetTemporaryPlaylist(response_);
        })).pipe(_observableCatch(function (response_) {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return _this.processGetTemporaryPlaylist(response_);
                }
                catch (e) {
                    return _observableThrow(e);
                }
            }
            else
                return _observableThrow(response_);
        }));
    };
    PlaylistClient.prototype.processGetTemporaryPlaylist = function (response) {
        var status = response.status;
        var responseBlob = response instanceof HttpResponse ? response.body :
            response.error instanceof Blob ? response.error : undefined;
        var _headers = {};
        if (response.headers) {
            for (var _i = 0, _a = response.headers.keys(); _i < _a.length; _i++) {
                var key = _a[_i];
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200 || status === 206) {
            var contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            var fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            var fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob, status: status, headers: _headers });
        }
        else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(function (_responseText) {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null);
    };
    PlaylistClient.ngInjectableDef = i0.ɵɵdefineInjectable({ factory: function PlaylistClient_Factory() { return new PlaylistClient(i0.ɵɵinject(i1.HttpClient), i0.ɵɵinject(OBSCURITAS_MEDIA_MANAGER_BACKEND_API_BASE_URL, 8)); }, token: PlaylistClient, providedIn: "root" });
    PlaylistClient = tslib_1.__decorate([
        Injectable({
            providedIn: 'root'
        }),
        tslib_1.__param(0, Inject(HttpClient)), tslib_1.__param(1, Optional()), tslib_1.__param(1, Inject(OBSCURITAS_MEDIA_MANAGER_BACKEND_API_BASE_URL)),
        tslib_1.__metadata("design:paramtypes", [HttpClient, String])
    ], PlaylistClient);
    return PlaylistClient;
}());
export { PlaylistClient };
var StreamingClient = /** @class */ (function () {
    function StreamingClient(http, baseUrl) {
        this.jsonParseReviver = undefined;
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }
    StreamingClient.prototype.batchPostStreamingEntries = function (streamingEntries) {
        var _this = this;
        var url_ = this.baseUrl + "/api/Streaming";
        url_ = url_.replace(/[?&]$/, "");
        var content_ = JSON.stringify(streamingEntries);
        var options_ = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };
        return this.http.request("post", url_, options_).pipe(_observableMergeMap(function (response_) {
            return _this.processBatchPostStreamingEntries(response_);
        })).pipe(_observableCatch(function (response_) {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return _this.processBatchPostStreamingEntries(response_);
                }
                catch (e) {
                    return _observableThrow(e);
                }
            }
            else
                return _observableThrow(response_);
        }));
    };
    StreamingClient.prototype.processBatchPostStreamingEntries = function (response) {
        var status = response.status;
        var responseBlob = response instanceof HttpResponse ? response.body :
            response.error instanceof Blob ? response.error : undefined;
        var _headers = {};
        if (response.headers) {
            for (var _i = 0, _a = response.headers.keys(); _i < _a.length; _i++) {
                var key = _a[_i];
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200 || status === 206) {
            var contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            var fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            var fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob, status: status, headers: _headers });
        }
        else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(function (_responseText) {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null);
    };
    StreamingClient.prototype.getStreamingEntry = function (guid) {
        var _this = this;
        var url_ = this.baseUrl + "/api/Streaming/{guid}";
        if (guid === undefined || guid === null)
            throw new Error("The parameter 'guid' must be defined.");
        url_ = url_.replace("{guid}", encodeURIComponent("" + guid));
        url_ = url_.replace(/[?&]$/, "");
        var options_ = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };
        return this.http.request("get", url_, options_).pipe(_observableMergeMap(function (response_) {
            return _this.processGetStreamingEntry(response_);
        })).pipe(_observableCatch(function (response_) {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return _this.processGetStreamingEntry(response_);
                }
                catch (e) {
                    return _observableThrow(e);
                }
            }
            else
                return _observableThrow(response_);
        }));
    };
    StreamingClient.prototype.processGetStreamingEntry = function (response) {
        var status = response.status;
        var responseBlob = response instanceof HttpResponse ? response.body :
            response.error instanceof Blob ? response.error : undefined;
        var _headers = {};
        if (response.headers) {
            for (var _i = 0, _a = response.headers.keys(); _i < _a.length; _i++) {
                var key = _a[_i];
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200 || status === 206) {
            var contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            var fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            var fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob, status: status, headers: _headers });
        }
        else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(function (_responseText) {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null);
    };
    StreamingClient.prototype.getStream = function (guid, season, episode) {
        var _this = this;
        var url_ = this.baseUrl + "/api/Streaming/{guid}/season/{season}/episode/{episode}";
        if (guid === undefined || guid === null)
            throw new Error("The parameter 'guid' must be defined.");
        url_ = url_.replace("{guid}", encodeURIComponent("" + guid));
        if (season === undefined || season === null)
            throw new Error("The parameter 'season' must be defined.");
        url_ = url_.replace("{season}", encodeURIComponent("" + season));
        if (episode === undefined || episode === null)
            throw new Error("The parameter 'episode' must be defined.");
        url_ = url_.replace("{episode}", encodeURIComponent("" + episode));
        url_ = url_.replace(/[?&]$/, "");
        var options_ = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };
        return this.http.request("get", url_, options_).pipe(_observableMergeMap(function (response_) {
            return _this.processGetStream(response_);
        })).pipe(_observableCatch(function (response_) {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return _this.processGetStream(response_);
                }
                catch (e) {
                    return _observableThrow(e);
                }
            }
            else
                return _observableThrow(response_);
        }));
    };
    StreamingClient.prototype.processGetStream = function (response) {
        var status = response.status;
        var responseBlob = response instanceof HttpResponse ? response.body :
            response.error instanceof Blob ? response.error : undefined;
        var _headers = {};
        if (response.headers) {
            for (var _i = 0, _a = response.headers.keys(); _i < _a.length; _i++) {
                var key = _a[_i];
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200 || status === 206) {
            var contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            var fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            var fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob, status: status, headers: _headers });
        }
        else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(function (_responseText) {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null);
    };
    StreamingClient.ngInjectableDef = i0.ɵɵdefineInjectable({ factory: function StreamingClient_Factory() { return new StreamingClient(i0.ɵɵinject(i1.HttpClient), i0.ɵɵinject(OBSCURITAS_MEDIA_MANAGER_BACKEND_API_BASE_URL, 8)); }, token: StreamingClient, providedIn: "root" });
    StreamingClient = tslib_1.__decorate([
        Injectable({
            providedIn: 'root'
        }),
        tslib_1.__param(0, Inject(HttpClient)), tslib_1.__param(1, Optional()), tslib_1.__param(1, Inject(OBSCURITAS_MEDIA_MANAGER_BACKEND_API_BASE_URL)),
        tslib_1.__metadata("design:paramtypes", [HttpClient, String])
    ], StreamingClient);
    return StreamingClient;
}());
export { StreamingClient };
var MediaModel = /** @class */ (function () {
    function MediaModel(data) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    this[property] = data[property];
            }
        }
    }
    MediaModel.prototype.init = function (_data) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.type = _data["type"];
            this.rating = _data["rating"];
            this.release = _data["release"];
            this.genreString = _data["genreString"];
            if (Array.isArray(_data["genres"])) {
                this.genres = [];
                for (var _i = 0, _a = _data["genres"]; _i < _a.length; _i++) {
                    var item = _a[_i];
                    this.genres.push(item);
                }
            }
            this.state = _data["state"];
            this.description = _data["description"];
            this.image = _data["image"];
        }
    };
    MediaModel.fromJS = function (data) {
        data = typeof data === 'object' ? data : {};
        var result = new MediaModel();
        result.init(data);
        return result;
    };
    MediaModel.prototype.toJSON = function (data) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["type"] = this.type;
        data["rating"] = this.rating;
        data["release"] = this.release;
        data["genreString"] = this.genreString;
        if (Array.isArray(this.genres)) {
            data["genres"] = [];
            for (var _i = 0, _a = this.genres; _i < _a.length; _i++) {
                var item = _a[_i];
                data["genres"].push(item);
            }
        }
        data["state"] = this.state;
        data["description"] = this.description;
        data["image"] = this.image;
        return data;
    };
    return MediaModel;
}());
export { MediaModel };
var UpdateImageRequest = /** @class */ (function () {
    function UpdateImageRequest(data) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    this[property] = data[property];
            }
        }
    }
    UpdateImageRequest.prototype.init = function (_data) {
        if (_data) {
            this.image = _data["image"];
        }
    };
    UpdateImageRequest.fromJS = function (data) {
        data = typeof data === 'object' ? data : {};
        var result = new UpdateImageRequest();
        result.init(data);
        return result;
    };
    UpdateImageRequest.prototype.toJSON = function (data) {
        data = typeof data === 'object' ? data : {};
        data["image"] = this.image;
        return data;
    };
    return UpdateImageRequest;
}());
export { UpdateImageRequest };
var MusicModel = /** @class */ (function () {
    function MusicModel(data) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    this[property] = data[property];
            }
        }
    }
    MusicModel.prototype.init = function (_data) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.author = _data["author"];
            this.source = _data["source"];
            this.mood = _data["mood"];
            this.language = _data["language"];
            this.nation = _data["nation"];
            this.instrumentation = _data["instrumentation"];
            this.participants = _data["participants"];
            this.instrumentsString = _data["instrumentsString"];
            this.genreString = _data["genreString"];
            if (Array.isArray(_data["genres"])) {
                this.genres = [];
                for (var _i = 0, _a = _data["genres"]; _i < _a.length; _i++) {
                    var item = _a[_i];
                    this.genres.push(item);
                }
            }
            this.src = _data["src"];
            this.rating = _data["rating"];
            this.complete = _data["complete"];
        }
    };
    MusicModel.fromJS = function (data) {
        data = typeof data === 'object' ? data : {};
        var result = new MusicModel();
        result.init(data);
        return result;
    };
    MusicModel.prototype.toJSON = function (data) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["author"] = this.author;
        data["source"] = this.source;
        data["mood"] = this.mood;
        data["language"] = this.language;
        data["nation"] = this.nation;
        data["instrumentation"] = this.instrumentation;
        data["participants"] = this.participants;
        data["instrumentsString"] = this.instrumentsString;
        data["genreString"] = this.genreString;
        if (Array.isArray(this.genres)) {
            data["genres"] = [];
            for (var _i = 0, _a = this.genres; _i < _a.length; _i++) {
                var item = _a[_i];
                data["genres"].push(item);
            }
        }
        data["src"] = this.src;
        data["rating"] = this.rating;
        data["complete"] = this.complete;
        return data;
    };
    return MusicModel;
}());
export { MusicModel };
export var Mood;
(function (Mood) {
    Mood["Unset"] = "Unset";
    Mood["Happy"] = "Happy";
    Mood["Aggressive"] = "Aggressive";
    Mood["Sad"] = "Sad";
    Mood["Calm"] = "Calm";
    Mood["Romantic"] = "Romantic";
    Mood["Dramatic"] = "Dramatic";
    Mood["Epic"] = "Epic";
    Mood["Funny"] = "Funny";
    Mood["Passionate"] = "Passionate";
    Mood["Monotonuous"] = "Monotonuous";
})(Mood || (Mood = {}));
export var Nation;
(function (Nation) {
    Nation["Unset"] = "Unset";
    Nation["Japanese"] = "Japanese";
    Nation["English"] = "English";
    Nation["German"] = "German";
    Nation["Spain"] = "Spain";
    Nation["Chinese"] = "Chinese";
    Nation["Italian"] = "Italian";
    Nation["Russian"] = "Russian";
    Nation["SouthAmerican"] = "SouthAmerican";
    Nation["African"] = "African";
})(Nation || (Nation = {}));
export var Instrumentation;
(function (Instrumentation) {
    Instrumentation["Unset"] = "Unset";
    Instrumentation["Mono"] = "Mono";
    Instrumentation["Groups"] = "Groups";
    Instrumentation["Mixed"] = "Mixed";
})(Instrumentation || (Instrumentation = {}));
export var Participants;
(function (Participants) {
    Participants["Unset"] = "Unset";
    Participants["Solo"] = "Solo";
    Participants["SmallGroup"] = "SmallGroup";
    Participants["LargeGroup"] = "LargeGroup";
    Participants["SmallOrchestra"] = "SmallOrchestra";
    Participants["LargeOrchestra"] = "LargeOrchestra";
})(Participants || (Participants = {}));
export var Genre;
(function (Genre) {
    Genre["Unset"] = "Unset";
    Genre["Avantgarde"] = "Avantgarde";
    Genre["Blues"] = "Blues";
    Genre["Classic"] = "Classic";
    Genre["Comedy"] = "Comedy";
    Genre["Country"] = "Country";
    Genre["EasyListening"] = "EasyListening";
    Genre["Electronic"] = "Electronic";
    Genre["House"] = "House";
    Genre["Flamenco"] = "Flamenco";
    Genre["Folk"] = "Folk";
    Genre["Jazz"] = "Jazz";
    Genre["Latin"] = "Latin";
    Genre["Pop"] = "Pop";
    Genre["RnB"] = "RnB";
    Genre["Soul"] = "Soul";
    Genre["Rock"] = "Rock";
    Genre["Metal"] = "Metal";
    Genre["March"] = "March";
    Genre["Moe"] = "Moe";
    Genre["Wagakki"] = "Wagakki";
    Genre["Medley"] = "Medley";
    Genre["Parody"] = "Parody";
    Genre["Ballad"] = "Ballad";
    Genre["FilmMusic"] = "FilmMusic";
})(Genre || (Genre = {}));
var InstrumentModel = /** @class */ (function () {
    function InstrumentModel(data) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    this[property] = data[property];
            }
        }
    }
    InstrumentModel.prototype.init = function (_data) {
        if (_data) {
            this.name = _data["name"];
            this.type = _data["type"];
        }
    };
    InstrumentModel.fromJS = function (data) {
        data = typeof data === 'object' ? data : {};
        var result = new InstrumentModel();
        result.init(data);
        return result;
    };
    InstrumentModel.prototype.toJSON = function (data) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["type"] = this.type;
        return data;
    };
    return InstrumentModel;
}());
export { InstrumentModel };
export var InstrumentType;
(function (InstrumentType) {
    InstrumentType["Unset"] = "Unset";
    InstrumentType["Vocal"] = "Vocal";
    InstrumentType["WoodWind"] = "WoodWind";
    InstrumentType["Brass"] = "Brass";
    InstrumentType["Percussion"] = "Percussion";
    InstrumentType["Stringed"] = "Stringed";
    InstrumentType["Keyboard"] = "Keyboard";
    InstrumentType["Electronic"] = "Electronic";
})(InstrumentType || (InstrumentType = {}));
var UpdateRequestOfMusicModel = /** @class */ (function () {
    function UpdateRequestOfMusicModel(data) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    this[property] = data[property];
            }
        }
    }
    UpdateRequestOfMusicModel.prototype.init = function (_data) {
        if (_data) {
            this.oldModel = _data["oldModel"] ? MusicModel.fromJS(_data["oldModel"]) : undefined;
            this.newModel = _data["newModel"] ? MusicModel.fromJS(_data["newModel"]) : undefined;
        }
    };
    UpdateRequestOfMusicModel.fromJS = function (data) {
        data = typeof data === 'object' ? data : {};
        var result = new UpdateRequestOfMusicModel();
        result.init(data);
        return result;
    };
    UpdateRequestOfMusicModel.prototype.toJSON = function (data) {
        data = typeof data === 'object' ? data : {};
        data["oldModel"] = this.oldModel ? this.oldModel.toJSON() : undefined;
        data["newModel"] = this.newModel ? this.newModel.toJSON() : undefined;
        return data;
    };
    return UpdateRequestOfMusicModel;
}());
export { UpdateRequestOfMusicModel };
var StreamingEntryModel = /** @class */ (function () {
    function StreamingEntryModel(data) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    this[property] = data[property];
            }
        }
    }
    StreamingEntryModel.prototype.init = function (_data) {
        if (_data) {
            this.id = _data["id"];
            this.season = _data["season"];
            this.episode = _data["episode"];
            this.src = _data["src"];
        }
    };
    StreamingEntryModel.fromJS = function (data) {
        data = typeof data === 'object' ? data : {};
        var result = new StreamingEntryModel();
        result.init(data);
        return result;
    };
    StreamingEntryModel.prototype.toJSON = function (data) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["season"] = this.season;
        data["episode"] = this.episode;
        data["src"] = this.src;
        return data;
    };
    return StreamingEntryModel;
}());
export { StreamingEntryModel };
var SwaggerException = /** @class */ (function (_super) {
    tslib_1.__extends(SwaggerException, _super);
    function SwaggerException(message, status, response, headers, result) {
        var _this = _super.call(this) || this;
        _this.isSwaggerException = true;
        _this.message = message;
        _this.status = status;
        _this.response = response;
        _this.headers = headers;
        _this.result = result;
        return _this;
    }
    SwaggerException.isSwaggerException = function (obj) {
        return obj.isSwaggerException === true;
    };
    return SwaggerException;
}(Error));
export { SwaggerException };
function throwException(message, status, response, headers, result) {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new SwaggerException(message, status, response, headers, null));
}
function blobToText(blob) {
    return new Observable(function (observer) {
        if (!blob) {
            observer.next("");
            observer.complete();
        }
        else {
            var reader = new FileReader();
            reader.onload = function (event) {
                observer.next(event.target.result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}
