/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.15.9.0 (NJsonSchema v10.6.8.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming
// @ts-nocheck
export class CleanupClient {
    http;
    baseUrl;
    jsonParseReviver = undefined;
    constructor(baseUrl, http) {
        this.http = http ? http : window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }
    getBrokenAudioTracks(signal) {
        let url_ = this.baseUrl + "/api/Cleanup/music";
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processGetBrokenAudioTracks(_response);
        });
    }
    processGetBrokenAudioTracks(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => _headers[k] = v);
        }
        ;
        let _mappings = [];
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
                if (Array.isArray(resultData200)) {
                    result200 = [];
                    for (let item of resultData200)
                        result200.push(MusicModel.fromJS(item, _mappings));
                }
                else {
                    result200 = null;
                }
                return result200;
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    validateMediaRoot(rootPath, signal) {
        let url_ = this.baseUrl + "/api/Cleanup/validate-media-root";
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(rootPath);
        let options_ = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processValidateMediaRoot(_response);
        });
    }
    processValidateMediaRoot(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => _headers[k] = v);
        }
        ;
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : null;
                return result200;
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
}
export class FileClient {
    http;
    baseUrl;
    jsonParseReviver = undefined;
    constructor(baseUrl, http) {
        this.http = http ? http : window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }
    getVideo(videoPath, signal) {
        let url_ = this.baseUrl + "/api/File/video?";
        if (videoPath !== undefined && videoPath !== null)
            url_ += "videoPath=" + encodeURIComponent("" + videoPath) + "&";
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processGetVideo(_response);
        });
    }
    processGetVideo(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => _headers[k] = v);
        }
        ;
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    getAudio(audioPath, highCompatibility, signal) {
        let url_ = this.baseUrl + "/api/File/audio?";
        if (audioPath !== undefined && audioPath !== null)
            url_ += "audioPath=" + encodeURIComponent("" + audioPath) + "&";
        if (highCompatibility === null)
            throw new Error("The parameter 'highCompatibility' cannot be null.");
        else if (highCompatibility !== undefined)
            url_ += "highCompatibility=" + encodeURIComponent("" + highCompatibility) + "&";
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processGetAudio(_response);
        });
    }
    processGetAudio(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => _headers[k] = v);
        }
        ;
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    validate(fileUrls, signal) {
        let url_ = this.baseUrl + "/api/File/validate-files";
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(fileUrls);
        let options_ = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processValidate(_response);
        });
    }
    processValidate(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => _headers[k] = v);
        }
        ;
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : null;
                return result200;
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
}
export class GenreClient {
    http;
    baseUrl;
    jsonParseReviver = undefined;
    constructor(baseUrl, http) {
        this.http = http ? http : window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }
    getAll(signal) {
        let url_ = this.baseUrl + "/api/Genre";
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processGetAll(_response);
        });
    }
    processGetAll(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => _headers[k] = v);
        }
        ;
        let _mappings = [];
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
                if (Array.isArray(resultData200)) {
                    result200 = [];
                    for (let item of resultData200)
                        result200.push(GenreModel.fromJS(item, _mappings));
                }
                else {
                    result200 = null;
                }
                return result200;
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    addGenre(section, name, signal) {
        let url_ = this.baseUrl + "/api/Genre/section/{section}/name/{name}";
        if (section === undefined || section === null)
            throw new Error("The parameter 'section' must be defined.");
        url_ = url_.replace("{section}", encodeURIComponent("" + section));
        if (name === undefined || name === null)
            throw new Error("The parameter 'name' must be defined.");
        url_ = url_.replace("{name}", encodeURIComponent("" + name));
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "PUT",
            signal,
            headers: {}
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processAddGenre(_response);
        });
    }
    processAddGenre(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => _headers[k] = v);
        }
        ;
        if (status === 200) {
            return response.text().then((_responseText) => {
                return;
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    removeGenre(id, signal) {
        let url_ = this.baseUrl + "/api/Genre/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "DELETE",
            signal,
            headers: {}
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processRemoveGenre(_response);
        });
    }
    processRemoveGenre(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => _headers[k] = v);
        }
        ;
        if (status === 200) {
            return response.text().then((_responseText) => {
                return;
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
}
export class LoginClient {
    http;
    baseUrl;
    jsonParseReviver = undefined;
    constructor(baseUrl, http) {
        this.http = http ? http : window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }
    login(request, signal) {
        let url_ = this.baseUrl + "/api/Login";
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(request);
        let options_ = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processLogin(_response);
        });
    }
    processLogin(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => _headers[k] = v);
        }
        ;
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : null;
                return result200;
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
}
export class MediaClient {
    http;
    baseUrl;
    jsonParseReviver = undefined;
    constructor(baseUrl, http) {
        this.http = http ? http : window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }
    get(guid, signal) {
        let url_ = this.baseUrl + "/api/Media/{guid}";
        if (guid === undefined || guid === null)
            throw new Error("The parameter 'guid' must be defined.");
        url_ = url_.replace("{guid}", encodeURIComponent("" + guid));
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processGet(_response);
        });
    }
    processGet(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => _headers[k] = v);
        }
        ;
        let _mappings = [];
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
                result200 = MediaModel.fromJS(resultData200, _mappings);
                return result200;
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    getAll(signal) {
        let url_ = this.baseUrl + "/api/Media";
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processGetAll(_response);
        });
    }
    processGetAll(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => _headers[k] = v);
        }
        ;
        let _mappings = [];
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
                if (Array.isArray(resultData200)) {
                    result200 = [];
                    for (let item of resultData200)
                        result200.push(MediaModel.fromJS(item, _mappings));
                }
                else {
                    result200 = null;
                }
                return result200;
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    createFromMediaPath(request, signal) {
        let url_ = this.baseUrl + "/api/Media";
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(request);
        let options_ = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processCreateFromMediaPath(_response);
        });
    }
    processCreateFromMediaPath(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => _headers[k] = v);
        }
        ;
        let _mappings = [];
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
                result200 = KeyValuePairOfNullableGuidAndModelCreationState.fromJS(resultData200, _mappings);
                return result200;
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    updateMedia(id, _, signal) {
        let url_ = this.baseUrl + "/api/Media/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(_);
        let options_ = {
            body: content_,
            method: "PUT",
            signal,
            headers: {
                "Content-Type": "application/json",
            }
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processUpdateMedia(_response);
        });
    }
    processUpdateMedia(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => _headers[k] = v);
        }
        ;
        if (status === 200) {
            return response.text().then((_responseText) => {
                return;
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    addMediaImage(image, guid, signal) {
        let url_ = this.baseUrl + "/api/Media/{guid}/image";
        if (guid === undefined || guid === null)
            throw new Error("The parameter 'guid' must be defined.");
        url_ = url_.replace("{guid}", encodeURIComponent("" + guid));
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(image);
        let options_ = {
            body: content_,
            method: "PUT",
            signal,
            headers: {
                "Content-Type": "application/json",
            }
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processAddMediaImage(_response);
        });
    }
    processAddMediaImage(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => _headers[k] = v);
        }
        ;
        if (status === 200) {
            return response.text().then((_responseText) => {
                return;
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    deleteMediaImage(guid, signal) {
        let url_ = this.baseUrl + "/api/Media/{guid}/image";
        if (guid === undefined || guid === null)
            throw new Error("The parameter 'guid' must be defined.");
        url_ = url_.replace("{guid}", encodeURIComponent("" + guid));
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "DELETE",
            signal,
            headers: {}
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processDeleteMediaImage(_response);
        });
    }
    processDeleteMediaImage(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => _headers[k] = v);
        }
        ;
        if (status === 200) {
            return response.text().then((_responseText) => {
                return;
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
}
export class MusicClient {
    http;
    baseUrl;
    jsonParseReviver = undefined;
    constructor(baseUrl, http) {
        this.http = http ? http : window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }
    getDefault(signal) {
        let url_ = this.baseUrl + "/api/Music/default";
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processGetDefault(_response);
        });
    }
    processGetDefault(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => _headers[k] = v);
        }
        ;
        let _mappings = [];
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
                result200 = MusicModel.fromJS(resultData200, _mappings);
                return result200;
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    createMusicTrack(track, signal) {
        let url_ = this.baseUrl + "/api/Music/track";
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(track);
        let options_ = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processCreateMusicTrack(_response);
        });
    }
    processCreateMusicTrack(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => _headers[k] = v);
        }
        ;
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : null;
                return result200;
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    createMusicTrackFromPath(trackPath, signal) {
        let url_ = this.baseUrl + "/api/Music/tracks";
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(trackPath);
        let options_ = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processCreateMusicTrackFromPath(_response);
        });
    }
    processCreateMusicTrackFromPath(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => _headers[k] = v);
        }
        ;
        let _mappings = [];
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
                result200 = KeyValuePairOfStringAndModelCreationState.fromJS(resultData200, _mappings);
                return result200;
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    recalculateHashes(signal) {
        let url_ = this.baseUrl + "/api/Music/recalculate-hashes";
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "POST",
            signal,
            headers: {}
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processRecalculateHashes(_response);
        });
    }
    processRecalculateHashes(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => _headers[k] = v);
        }
        ;
        if (status === 200) {
            return response.text().then((_responseText) => {
                return;
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    getAll(signal) {
        let url_ = this.baseUrl + "/api/Music";
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processGetAll(_response);
        });
    }
    processGetAll(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => _headers[k] = v);
        }
        ;
        let _mappings = [];
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
                if (Array.isArray(resultData200)) {
                    result200 = [];
                    for (let item of resultData200)
                        result200.push(MusicModel.fromJS(item, _mappings));
                }
                else {
                    result200 = null;
                }
                return result200;
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    get(hash, signal) {
        let url_ = this.baseUrl + "/api/Music/{hash}";
        if (hash === undefined || hash === null)
            throw new Error("The parameter 'hash' must be defined.");
        url_ = url_.replace("{hash}", encodeURIComponent("" + hash));
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processGet(_response);
        });
    }
    processGet(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => _headers[k] = v);
        }
        ;
        let _mappings = [];
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
                result200 = MusicModel.fromJS(resultData200, _mappings);
                return result200;
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    update(hash, _, signal) {
        let url_ = this.baseUrl + "/api/Music/{hash}";
        if (hash === undefined || hash === null)
            throw new Error("The parameter 'hash' must be defined.");
        url_ = url_.replace("{hash}", encodeURIComponent("" + hash));
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(_);
        let options_ = {
            body: content_,
            method: "PUT",
            signal,
            headers: {
                "Content-Type": "application/json",
            }
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processUpdate(_response);
        });
    }
    processUpdate(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => _headers[k] = v);
        }
        ;
        if (status === 200) {
            return response.text().then((_responseText) => {
                return;
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    getLyrics(hash, offset, signal) {
        let url_ = this.baseUrl + "/api/Music/{hash}/lyrics?";
        if (hash === undefined || hash === null)
            throw new Error("The parameter 'hash' must be defined.");
        url_ = url_.replace("{hash}", encodeURIComponent("" + hash));
        if (offset === null)
            throw new Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "offset=" + encodeURIComponent("" + offset) + "&";
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processGetLyrics(_response);
        });
    }
    processGetLyrics(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => _headers[k] = v);
        }
        ;
        let _mappings = [];
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
                result200 = LyricsResponse.fromJS(resultData200, _mappings);
                return result200;
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    getInstruments(signal) {
        let url_ = this.baseUrl + "/api/Music/instruments";
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processGetInstruments(_response);
        });
    }
    processGetInstruments(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => _headers[k] = v);
        }
        ;
        let _mappings = [];
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
                if (Array.isArray(resultData200)) {
                    result200 = [];
                    for (let item of resultData200)
                        result200.push(InstrumentModel.fromJS(item, _mappings));
                }
                else {
                    result200 = null;
                }
                return result200;
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    addInstrument(type, name, signal) {
        let url_ = this.baseUrl + "/api/Music/instrument/{name}/type/{type}";
        if (type === undefined || type === null)
            throw new Error("The parameter 'type' must be defined.");
        url_ = url_.replace("{type}", encodeURIComponent("" + type));
        if (name === undefined || name === null)
            throw new Error("The parameter 'name' must be defined.");
        url_ = url_.replace("{name}", encodeURIComponent("" + name));
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "PUT",
            signal,
            headers: {}
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processAddInstrument(_response);
        });
    }
    processAddInstrument(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => _headers[k] = v);
        }
        ;
        if (status === 200) {
            return response.text().then((_responseText) => {
                return;
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    removeInstrument(type, name, signal) {
        let url_ = this.baseUrl + "/api/Music/instrument/{name}/type/{type}";
        if (type === undefined || type === null)
            throw new Error("The parameter 'type' must be defined.");
        url_ = url_.replace("{type}", encodeURIComponent("" + type));
        if (name === undefined || name === null)
            throw new Error("The parameter 'name' must be defined.");
        url_ = url_.replace("{name}", encodeURIComponent("" + name));
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "DELETE",
            signal,
            headers: {}
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processRemoveInstrument(_response);
        });
    }
    processRemoveInstrument(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => _headers[k] = v);
        }
        ;
        if (status === 200) {
            return response.text().then((_responseText) => {
                return;
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    softDeleteTracks(trackHashes, signal) {
        let url_ = this.baseUrl + "/api/Music/music/soft";
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(trackHashes);
        let options_ = {
            body: content_,
            method: "DELETE",
            signal,
            headers: {
                "Content-Type": "application/json",
            }
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processSoftDeleteTracks(_response);
        });
    }
    processSoftDeleteTracks(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => _headers[k] = v);
        }
        ;
        if (status === 200) {
            return response.text().then((_responseText) => {
                return;
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    undeleteTracks(trackHashes, signal) {
        let url_ = this.baseUrl + "/api/Music/music/undelete";
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(trackHashes);
        let options_ = {
            body: content_,
            method: "PUT",
            signal,
            headers: {
                "Content-Type": "application/json",
            }
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processUndeleteTracks(_response);
        });
    }
    processUndeleteTracks(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => _headers[k] = v);
        }
        ;
        if (status === 200) {
            return response.text().then((_responseText) => {
                return;
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    hardDeleteTracks(trackHashes, signal) {
        let url_ = this.baseUrl + "/api/Music/music/hard";
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(trackHashes);
        let options_ = {
            body: content_,
            method: "DELETE",
            signal,
            headers: {
                "Content-Type": "application/json",
            }
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processHardDeleteTracks(_response);
        });
    }
    processHardDeleteTracks(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => _headers[k] = v);
        }
        ;
        if (status === 200) {
            return response.text().then((_responseText) => {
                return;
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
}
export class PlaylistClient {
    http;
    baseUrl;
    jsonParseReviver = undefined;
    constructor(baseUrl, http) {
        this.http = http ? http : window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }
    getDummyPlaylist(signal) {
        let url_ = this.baseUrl + "/api/Playlist/dummy";
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processGetDummyPlaylist(_response);
        });
    }
    processGetDummyPlaylist(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => _headers[k] = v);
        }
        ;
        let _mappings = [];
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
                result200 = PlaylistModel.fromJS(resultData200, _mappings);
                return result200;
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    createTemporaryPlaylist(hashes, signal) {
        let url_ = this.baseUrl + "/api/Playlist/temp";
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(hashes);
        let options_ = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processCreateTemporaryPlaylist(_response);
        });
    }
    processCreateTemporaryPlaylist(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => _headers[k] = v);
        }
        ;
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : null;
                return result200;
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    getPlaylist(playlistId, signal) {
        let url_ = this.baseUrl + "/api/Playlist/{playlistId}";
        if (playlistId === undefined || playlistId === null)
            throw new Error("The parameter 'playlistId' must be defined.");
        url_ = url_.replace("{playlistId}", encodeURIComponent("" + playlistId));
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processGetPlaylist(_response);
        });
    }
    processGetPlaylist(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => _headers[k] = v);
        }
        ;
        let _mappings = [];
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
                result200 = PlaylistModel.fromJS(resultData200, _mappings);
                return result200;
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    updatePlaylistData(playlistId, updateRequest, signal) {
        let url_ = this.baseUrl + "/api/Playlist/{playlistId}";
        if (playlistId === undefined || playlistId === null)
            throw new Error("The parameter 'playlistId' must be defined.");
        url_ = url_.replace("{playlistId}", encodeURIComponent("" + playlistId));
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(updateRequest);
        let options_ = {
            body: content_,
            method: "PUT",
            signal,
            headers: {
                "Content-Type": "application/json",
            }
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processUpdatePlaylistData(_response);
        });
    }
    processUpdatePlaylistData(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => _headers[k] = v);
        }
        ;
        if (status === 200) {
            return response.text().then((_responseText) => {
                return;
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    deletePlaylist(playlistId, signal) {
        let url_ = this.baseUrl + "/api/Playlist/{playlistId}";
        if (playlistId === undefined || playlistId === null)
            throw new Error("The parameter 'playlistId' must be defined.");
        url_ = url_.replace("{playlistId}", encodeURIComponent("" + playlistId));
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "DELETE",
            signal,
            headers: {}
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processDeletePlaylist(_response);
        });
    }
    processDeletePlaylist(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => _headers[k] = v);
        }
        ;
        if (status === 200) {
            return response.text().then((_responseText) => {
                return;
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    listPlaylists(signal) {
        let url_ = this.baseUrl + "/api/Playlist/list";
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processListPlaylists(_response);
        });
    }
    processListPlaylists(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => _headers[k] = v);
        }
        ;
        let _mappings = [];
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
                if (Array.isArray(resultData200)) {
                    result200 = [];
                    for (let item of resultData200)
                        result200.push(PlaylistModel.fromJS(item, _mappings));
                }
                else {
                    result200 = null;
                }
                return result200;
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    createPlaylist(playlist, signal) {
        let url_ = this.baseUrl + "/api/Playlist/create";
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(playlist);
        let options_ = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
            }
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processCreatePlaylist(_response);
        });
    }
    processCreatePlaylist(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => _headers[k] = v);
        }
        ;
        if (status === 200) {
            return response.text().then((_responseText) => {
                return;
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    addTracksToPlaylist(playlistId, trackHashes, signal) {
        let url_ = this.baseUrl + "/api/Playlist/{playlistId}/tracks";
        if (playlistId === undefined || playlistId === null)
            throw new Error("The parameter 'playlistId' must be defined.");
        url_ = url_.replace("{playlistId}", encodeURIComponent("" + playlistId));
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(trackHashes);
        let options_ = {
            body: content_,
            method: "PUT",
            signal,
            headers: {
                "Content-Type": "application/json",
            }
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processAddTracksToPlaylist(_response);
        });
    }
    processAddTracksToPlaylist(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => _headers[k] = v);
        }
        ;
        if (status === 200) {
            return response.text().then((_responseText) => {
                return;
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
}
export class RecipeClient {
    http;
    baseUrl;
    jsonParseReviver = undefined;
    constructor(baseUrl, http) {
        this.http = http ? http : window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }
    getAllRecipes(signal) {
        let url_ = this.baseUrl + "/api/Recipe";
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processGetAllRecipes(_response);
        });
    }
    processGetAllRecipes(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => _headers[k] = v);
        }
        ;
        let _mappings = [];
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
                if (Array.isArray(resultData200)) {
                    result200 = [];
                    for (let item of resultData200)
                        result200.push(RecipeModel.fromJS(item, _mappings));
                }
                else {
                    result200 = null;
                }
                return result200;
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    createRecipe(recipe, signal) {
        let url_ = this.baseUrl + "/api/Recipe";
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(recipe);
        let options_ = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
            }
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processCreateRecipe(_response);
        });
    }
    processCreateRecipe(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => _headers[k] = v);
        }
        ;
        if (status === 200) {
            return response.text().then((_responseText) => {
                return;
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    updateRecipe(recipe, signal) {
        let url_ = this.baseUrl + "/api/Recipe";
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(recipe);
        let options_ = {
            body: content_,
            method: "PATCH",
            signal,
            headers: {
                "Content-Type": "application/json",
            }
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processUpdateRecipe(_response);
        });
    }
    processUpdateRecipe(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => _headers[k] = v);
        }
        ;
        if (status === 200) {
            return response.text().then((_responseText) => {
                return;
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    getRecipe(id, signal) {
        let url_ = this.baseUrl + "/api/Recipe/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processGetRecipe(_response);
        });
    }
    processGetRecipe(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => _headers[k] = v);
        }
        ;
        let _mappings = [];
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
                result200 = RecipeModel.fromJS(resultData200, _mappings);
                return result200;
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
}
export class MusicModel {
    name;
    displayName;
    author;
    source;
    mood1;
    mood2;
    language;
    instrumentation;
    participants;
    instruments;
    instrumentTypes;
    instrumentNames;
    genres;
    path;
    lyrics;
    rating;
    complete;
    hash;
    deleted;
    constructor(data) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property) && this.hasOwnProperty(property))
                    this[property] = data[property];
            }
        }
    }
    init(_data, _mappings) {
        if (_data) {
            this.name = _data["name"] !== undefined ? _data["name"] : null;
            this.displayName = _data["displayName"] !== undefined ? _data["displayName"] : null;
            this.author = _data["author"] !== undefined ? _data["author"] : null;
            this.source = _data["source"] !== undefined ? _data["source"] : null;
            this.mood1 = _data["mood1"] !== undefined ? _data["mood1"] : null;
            this.mood2 = _data["mood2"] !== undefined ? _data["mood2"] : null;
            this.language = _data["language"] !== undefined ? _data["language"] : null;
            this.instrumentation = _data["instrumentation"] !== undefined ? _data["instrumentation"] : null;
            this.participants = _data["participants"] !== undefined ? _data["participants"] : null;
            if (Array.isArray(_data["instruments"])) {
                this.instruments = [];
                for (let item of _data["instruments"])
                    this.instruments.push(InstrumentModel.fromJS(item, _mappings));
            }
            else {
                this.instruments = null;
            }
            if (Array.isArray(_data["instrumentTypes"])) {
                this.instrumentTypes = [];
                for (let item of _data["instrumentTypes"])
                    this.instrumentTypes.push(item);
            }
            else {
                this.instrumentTypes = null;
            }
            if (Array.isArray(_data["instrumentNames"])) {
                this.instrumentNames = [];
                for (let item of _data["instrumentNames"])
                    this.instrumentNames.push(item);
            }
            else {
                this.instrumentNames = null;
            }
            if (Array.isArray(_data["genres"])) {
                this.genres = [];
                for (let item of _data["genres"])
                    this.genres.push(item);
            }
            else {
                this.genres = null;
            }
            this.path = _data["path"] !== undefined ? _data["path"] : null;
            this.lyrics = _data["lyrics"] !== undefined ? _data["lyrics"] : null;
            this.rating = _data["rating"] !== undefined ? _data["rating"] : null;
            this.complete = _data["complete"] !== undefined ? _data["complete"] : null;
            this.hash = _data["hash"] !== undefined ? _data["hash"] : null;
            this.deleted = _data["deleted"] !== undefined ? _data["deleted"] : null;
        }
    }
    static fromJS(data, _mappings) {
        data = typeof data === 'object' ? data : {};
        return createInstance(data, _mappings, MusicModel);
    }
    toJSON(data) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name !== undefined ? this.name : null;
        data["displayName"] = this.displayName !== undefined ? this.displayName : null;
        data["author"] = this.author !== undefined ? this.author : null;
        data["source"] = this.source !== undefined ? this.source : null;
        data["mood1"] = this.mood1 !== undefined ? this.mood1 : null;
        data["mood2"] = this.mood2 !== undefined ? this.mood2 : null;
        data["language"] = this.language !== undefined ? this.language : null;
        data["instrumentation"] = this.instrumentation !== undefined ? this.instrumentation : null;
        data["participants"] = this.participants !== undefined ? this.participants : null;
        if (Array.isArray(this.instruments)) {
            data["instruments"] = [];
            for (let item of this.instruments)
                data["instruments"].push(item.toJSON());
        }
        if (Array.isArray(this.instrumentTypes)) {
            data["instrumentTypes"] = [];
            for (let item of this.instrumentTypes)
                data["instrumentTypes"].push(item);
        }
        if (Array.isArray(this.instrumentNames)) {
            data["instrumentNames"] = [];
            for (let item of this.instrumentNames)
                data["instrumentNames"].push(item);
        }
        if (Array.isArray(this.genres)) {
            data["genres"] = [];
            for (let item of this.genres)
                data["genres"].push(item);
        }
        data["path"] = this.path !== undefined ? this.path : null;
        data["lyrics"] = this.lyrics !== undefined ? this.lyrics : null;
        data["rating"] = this.rating !== undefined ? this.rating : null;
        data["complete"] = this.complete !== undefined ? this.complete : null;
        data["hash"] = this.hash !== undefined ? this.hash : null;
        data["deleted"] = this.deleted !== undefined ? this.deleted : null;
        return data;
    }
    clone() {
        const json = this.toJSON();
        let result = new MusicModel();
        result.init(json);
        return result;
    }
}
export var Mood;
(function (Mood) {
    Mood["Unset"] = "Unset";
    Mood["Happy"] = "Happy";
    Mood["Aggressive"] = "Aggressive";
    Mood["Sad"] = "Sad";
    Mood["Cool"] = "Cool";
    Mood["Calm"] = "Calm";
    Mood["Romantic"] = "Romantic";
    Mood["Dramatic"] = "Dramatic";
    Mood["Epic"] = "Epic";
    Mood["Funny"] = "Funny";
    Mood["Passionate"] = "Passionate";
    Mood["Monotonuous"] = "Monotonuous";
})(Mood || (Mood = {}));
export var Language;
(function (Language) {
    Language["Unset"] = "Unset";
    Language["Japanese"] = "Japanese";
    Language["English"] = "English";
    Language["German"] = "German";
    Language["Spain"] = "Spain";
    Language["Chinese"] = "Chinese";
    Language["Italian"] = "Italian";
    Language["Russian"] = "Russian";
    Language["SouthAmerican"] = "SouthAmerican";
    Language["African"] = "African";
    Language["Korean"] = "Korean";
})(Language || (Language = {}));
export var Instrumentation;
(function (Instrumentation) {
    Instrumentation["Unset"] = "Unset";
    Instrumentation["Mono"] = "Mono";
    Instrumentation["Groups"] = "Groups";
    Instrumentation["Mixed"] = "Mixed";
})(Instrumentation || (Instrumentation = {}));
export var Participants;
(function (Participants) {
    Participants["Unset"] = "Unset";
    Participants["Solo"] = "Solo";
    Participants["SmallGroup"] = "SmallGroup";
    Participants["LargeGroup"] = "LargeGroup";
    Participants["SmallOrchestra"] = "SmallOrchestra";
    Participants["LargeOrchestra"] = "LargeOrchestra";
})(Participants || (Participants = {}));
export class InstrumentModel {
    id;
    name;
    type;
    constructor(data) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property) && this.hasOwnProperty(property))
                    this[property] = data[property];
            }
        }
    }
    init(_data, _mappings) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : null;
            this.name = _data["name"] !== undefined ? _data["name"] : null;
            this.type = _data["type"] !== undefined ? _data["type"] : null;
        }
    }
    static fromJS(data, _mappings) {
        data = typeof data === 'object' ? data : {};
        return createInstance(data, _mappings, InstrumentModel);
    }
    toJSON(data) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : null;
        data["name"] = this.name !== undefined ? this.name : null;
        data["type"] = this.type !== undefined ? this.type : null;
        return data;
    }
    clone() {
        const json = this.toJSON();
        let result = new InstrumentModel();
        result.init(json);
        return result;
    }
}
export var InstrumentType;
(function (InstrumentType) {
    InstrumentType["Unset"] = "Unset";
    InstrumentType["Vocal"] = "Vocal";
    InstrumentType["WoodWind"] = "WoodWind";
    InstrumentType["Brass"] = "Brass";
    InstrumentType["Percussion"] = "Percussion";
    InstrumentType["Stringed"] = "Stringed";
    InstrumentType["Keyboard"] = "Keyboard";
    InstrumentType["Electronic"] = "Electronic";
    InstrumentType["HumanBody"] = "HumanBody";
    InstrumentType["Miscellaneous"] = "Miscellaneous";
})(InstrumentType || (InstrumentType = {}));
export var MusicGenre;
(function (MusicGenre) {
    MusicGenre["Unset"] = "Unset";
    MusicGenre["Acapella"] = "Acapella";
    MusicGenre["Avantgarde"] = "Avantgarde";
    MusicGenre["Blues"] = "Blues";
    MusicGenre["Classic"] = "Classic";
    MusicGenre["Comedy"] = "Comedy";
    MusicGenre["Country"] = "Country";
    MusicGenre["EasyListening"] = "EasyListening";
    MusicGenre["Electronic"] = "Electronic";
    MusicGenre["House"] = "House";
    MusicGenre["Flamenco"] = "Flamenco";
    MusicGenre["Folk"] = "Folk";
    MusicGenre["Jazz"] = "Jazz";
    MusicGenre["Latin"] = "Latin";
    MusicGenre["Pop"] = "Pop";
    MusicGenre["RnB"] = "RnB";
    MusicGenre["Soul"] = "Soul";
    MusicGenre["Rock"] = "Rock";
    MusicGenre["Metal"] = "Metal";
    MusicGenre["March"] = "March";
    MusicGenre["Moe"] = "Moe";
    MusicGenre["Wagakki"] = "Wagakki";
    MusicGenre["Medley"] = "Medley";
    MusicGenre["Parody"] = "Parody";
    MusicGenre["Ballad"] = "Ballad";
    MusicGenre["FilmMusic"] = "FilmMusic";
    MusicGenre["Western"] = "Western";
    MusicGenre["Christmas"] = "Christmas";
    MusicGenre["Enka"] = "Enka";
})(MusicGenre || (MusicGenre = {}));
export class GenreModel {
    id;
    section;
    name;
    constructor(data) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property) && this.hasOwnProperty(property))
                    this[property] = data[property];
            }
        }
    }
    init(_data, _mappings) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : null;
            this.section = _data["section"] !== undefined ? _data["section"] : null;
            this.name = _data["name"] !== undefined ? _data["name"] : null;
        }
    }
    static fromJS(data, _mappings) {
        data = typeof data === 'object' ? data : {};
        return createInstance(data, _mappings, GenreModel);
    }
    toJSON(data) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : null;
        data["section"] = this.section !== undefined ? this.section : null;
        data["name"] = this.name !== undefined ? this.name : null;
        return data;
    }
    clone() {
        const json = this.toJSON();
        let result = new GenreModel();
        result.init(json);
        return result;
    }
}
export class CredentialsRequest {
    username;
    password;
    constructor(data) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property) && this.hasOwnProperty(property))
                    this[property] = data[property];
            }
        }
    }
    init(_data, _mappings) {
        if (_data) {
            this.username = _data["username"] !== undefined ? _data["username"] : null;
            this.password = _data["password"] !== undefined ? _data["password"] : null;
        }
    }
    static fromJS(data, _mappings) {
        data = typeof data === 'object' ? data : {};
        return createInstance(data, _mappings, CredentialsRequest);
    }
    toJSON(data) {
        data = typeof data === 'object' ? data : {};
        data["username"] = this.username !== undefined ? this.username : null;
        data["password"] = this.password !== undefined ? this.password : null;
        return data;
    }
    clone() {
        const json = this.toJSON();
        let result = new CredentialsRequest();
        result.init(json);
        return result;
    }
}
export class MediaModel {
    contentWarnings;
    description;
    genres;
    hash;
    id;
    image;
    language;
    name;
    rating;
    release;
    status;
    targetGroup;
    type;
    rootFolderPath;
    constructor(data) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property) && this.hasOwnProperty(property))
                    this[property] = data[property];
            }
        }
    }
    init(_data, _mappings) {
        if (_data) {
            if (Array.isArray(_data["contentWarnings"])) {
                this.contentWarnings = [];
                for (let item of _data["contentWarnings"])
                    this.contentWarnings.push(item);
            }
            else {
                this.contentWarnings = null;
            }
            this.description = _data["description"] !== undefined ? _data["description"] : null;
            if (Array.isArray(_data["genres"])) {
                this.genres = [];
                for (let item of _data["genres"])
                    this.genres.push(GenreModel.fromJS(item, _mappings));
            }
            else {
                this.genres = null;
            }
            this.hash = _data["hash"] !== undefined ? _data["hash"] : null;
            this.id = _data["id"] !== undefined ? _data["id"] : null;
            this.image = _data["image"] !== undefined ? _data["image"] : null;
            this.language = _data["language"] !== undefined ? _data["language"] : null;
            this.name = _data["name"] !== undefined ? _data["name"] : null;
            this.rating = _data["rating"] !== undefined ? _data["rating"] : null;
            this.release = _data["release"] !== undefined ? _data["release"] : null;
            this.status = _data["status"] !== undefined ? _data["status"] : null;
            this.targetGroup = _data["targetGroup"] !== undefined ? _data["targetGroup"] : null;
            this.type = _data["type"] !== undefined ? _data["type"] : null;
            this.rootFolderPath = _data["rootFolderPath"] !== undefined ? _data["rootFolderPath"] : null;
        }
    }
    static fromJS(data, _mappings) {
        data = typeof data === 'object' ? data : {};
        return createInstance(data, _mappings, MediaModel);
    }
    toJSON(data) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.contentWarnings)) {
            data["contentWarnings"] = [];
            for (let item of this.contentWarnings)
                data["contentWarnings"].push(item);
        }
        data["description"] = this.description !== undefined ? this.description : null;
        if (Array.isArray(this.genres)) {
            data["genres"] = [];
            for (let item of this.genres)
                data["genres"].push(item.toJSON());
        }
        data["hash"] = this.hash !== undefined ? this.hash : null;
        data["id"] = this.id !== undefined ? this.id : null;
        data["image"] = this.image !== undefined ? this.image : null;
        data["language"] = this.language !== undefined ? this.language : null;
        data["name"] = this.name !== undefined ? this.name : null;
        data["rating"] = this.rating !== undefined ? this.rating : null;
        data["release"] = this.release !== undefined ? this.release : null;
        data["status"] = this.status !== undefined ? this.status : null;
        data["targetGroup"] = this.targetGroup !== undefined ? this.targetGroup : null;
        data["type"] = this.type !== undefined ? this.type : null;
        data["rootFolderPath"] = this.rootFolderPath !== undefined ? this.rootFolderPath : null;
        return data;
    }
    clone() {
        const json = this.toJSON();
        let result = new MediaModel();
        result.init(json);
        return result;
    }
}
export var ContentWarning;
(function (ContentWarning) {
    ContentWarning["Depression"] = "Depression";
    ContentWarning["Drugs"] = "Drugs";
    ContentWarning["Violence"] = "Violence";
    ContentWarning["Horror"] = "Horror";
    ContentWarning["Gore"] = "Gore";
    ContentWarning["Vulgarity"] = "Vulgarity";
    ContentWarning["Nudity"] = "Nudity";
})(ContentWarning || (ContentWarning = {}));
export var MediaStatus;
(function (MediaStatus) {
    MediaStatus["Completed"] = "Completed";
    MediaStatus["Airing"] = "Airing";
    MediaStatus["PreAiring"] = "PreAiring";
    MediaStatus["Aborted"] = "Aborted";
})(MediaStatus || (MediaStatus = {}));
export var TargetGroup;
(function (TargetGroup) {
    TargetGroup["Children"] = "Children";
    TargetGroup["Adolescents"] = "Adolescents";
    TargetGroup["Adults"] = "Adults";
    TargetGroup["Families"] = "Families";
    TargetGroup["Men"] = "Men";
    TargetGroup["Women"] = "Women";
    TargetGroup["None"] = "None";
})(TargetGroup || (TargetGroup = {}));
export var MediaCategory;
(function (MediaCategory) {
    MediaCategory["AnimeSeries"] = "AnimeSeries";
    MediaCategory["AnimeMovies"] = "AnimeMovies";
    MediaCategory["RealMovies"] = "RealMovies";
    MediaCategory["RealSeries"] = "RealSeries";
    MediaCategory["JDrama"] = "JDrama";
})(MediaCategory || (MediaCategory = {}));
export class KeyValuePairOfNullableGuidAndModelCreationState {
    key;
    value;
    constructor(data) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property) && this.hasOwnProperty(property))
                    this[property] = data[property];
            }
        }
    }
    init(_data, _mappings) {
        if (_data) {
            this.key = _data["key"] !== undefined ? _data["key"] : null;
            this.value = _data["value"] !== undefined ? _data["value"] : null;
        }
    }
    static fromJS(data, _mappings) {
        data = typeof data === 'object' ? data : {};
        return createInstance(data, _mappings, KeyValuePairOfNullableGuidAndModelCreationState);
    }
    toJSON(data) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key !== undefined ? this.key : null;
        data["value"] = this.value !== undefined ? this.value : null;
        return data;
    }
    clone() {
        const json = this.toJSON();
        let result = new KeyValuePairOfNullableGuidAndModelCreationState();
        result.init(json);
        return result;
    }
}
export var ModelCreationState;
(function (ModelCreationState) {
    ModelCreationState["Loading"] = "Loading";
    ModelCreationState["Success"] = "Success";
    ModelCreationState["Updated"] = "Updated";
    ModelCreationState["Ignored"] = "Ignored";
    ModelCreationState["Invalid"] = "Invalid";
    ModelCreationState["Error"] = "Error";
})(ModelCreationState || (ModelCreationState = {}));
export class MediaCreationRequest {
    rootPath;
    category;
    language;
    constructor(data) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property) && this.hasOwnProperty(property))
                    this[property] = data[property];
            }
        }
    }
    init(_data, _mappings) {
        if (_data) {
            this.rootPath = _data["rootPath"] !== undefined ? _data["rootPath"] : null;
            this.category = _data["category"] !== undefined ? _data["category"] : null;
            this.language = _data["language"] !== undefined ? _data["language"] : null;
        }
    }
    static fromJS(data, _mappings) {
        data = typeof data === 'object' ? data : {};
        return createInstance(data, _mappings, MediaCreationRequest);
    }
    toJSON(data) {
        data = typeof data === 'object' ? data : {};
        data["rootPath"] = this.rootPath !== undefined ? this.rootPath : null;
        data["category"] = this.category !== undefined ? this.category : null;
        data["language"] = this.language !== undefined ? this.language : null;
        return data;
    }
    clone() {
        const json = this.toJSON();
        let result = new MediaCreationRequest();
        result.init(json);
        return result;
    }
}
export class UpdateRequestOfJsonElement {
    oldModel;
    newModel;
    constructor(data) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property) && this.hasOwnProperty(property))
                    this[property] = data[property];
            }
        }
    }
    init(_data, _mappings) {
        if (_data) {
            this.oldModel = _data["oldModel"] !== undefined ? _data["oldModel"] : null;
            this.newModel = _data["newModel"] !== undefined ? _data["newModel"] : null;
        }
    }
    static fromJS(data, _mappings) {
        data = typeof data === 'object' ? data : {};
        return createInstance(data, _mappings, UpdateRequestOfJsonElement);
    }
    toJSON(data) {
        data = typeof data === 'object' ? data : {};
        data["oldModel"] = this.oldModel !== undefined ? this.oldModel : null;
        data["newModel"] = this.newModel !== undefined ? this.newModel : null;
        return data;
    }
    clone() {
        const json = this.toJSON();
        let result = new UpdateRequestOfJsonElement();
        result.init(json);
        return result;
    }
}
export class KeyValuePairOfStringAndModelCreationState {
    key;
    value;
    constructor(data) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property) && this.hasOwnProperty(property))
                    this[property] = data[property];
            }
        }
    }
    init(_data, _mappings) {
        if (_data) {
            this.key = _data["key"] !== undefined ? _data["key"] : null;
            this.value = _data["value"] !== undefined ? _data["value"] : null;
        }
    }
    static fromJS(data, _mappings) {
        data = typeof data === 'object' ? data : {};
        return createInstance(data, _mappings, KeyValuePairOfStringAndModelCreationState);
    }
    toJSON(data) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key !== undefined ? this.key : null;
        data["value"] = this.value !== undefined ? this.value : null;
        return data;
    }
    clone() {
        const json = this.toJSON();
        let result = new KeyValuePairOfStringAndModelCreationState();
        result.init(json);
        return result;
    }
}
export class LyricsResponse {
    title;
    text;
    constructor(data) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property) && this.hasOwnProperty(property))
                    this[property] = data[property];
            }
        }
    }
    init(_data, _mappings) {
        if (_data) {
            this.title = _data["title"] !== undefined ? _data["title"] : null;
            this.text = _data["text"] !== undefined ? _data["text"] : null;
        }
    }
    static fromJS(data, _mappings) {
        data = typeof data === 'object' ? data : {};
        return createInstance(data, _mappings, LyricsResponse);
    }
    toJSON(data) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title !== undefined ? this.title : null;
        data["text"] = this.text !== undefined ? this.text : null;
        return data;
    }
    clone() {
        const json = this.toJSON();
        let result = new LyricsResponse();
        result.init(json);
        return result;
    }
}
export class PlaylistModel {
    id;
    name;
    author;
    image;
    rating;
    language;
    nation;
    genres;
    complete;
    isTemporary;
    tracks;
    constructor(data) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property) && this.hasOwnProperty(property))
                    this[property] = data[property];
            }
        }
    }
    init(_data, _mappings) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : null;
            this.name = _data["name"] !== undefined ? _data["name"] : null;
            this.author = _data["author"] !== undefined ? _data["author"] : null;
            this.image = _data["image"] !== undefined ? _data["image"] : null;
            this.rating = _data["rating"] !== undefined ? _data["rating"] : null;
            this.language = _data["language"] !== undefined ? _data["language"] : null;
            this.nation = _data["nation"] !== undefined ? _data["nation"] : null;
            if (Array.isArray(_data["genres"])) {
                this.genres = [];
                for (let item of _data["genres"])
                    this.genres.push(item);
            }
            else {
                this.genres = null;
            }
            this.complete = _data["complete"] !== undefined ? _data["complete"] : null;
            this.isTemporary = _data["isTemporary"] !== undefined ? _data["isTemporary"] : null;
            if (Array.isArray(_data["tracks"])) {
                this.tracks = [];
                for (let item of _data["tracks"])
                    this.tracks.push(MusicModel.fromJS(item, _mappings));
            }
            else {
                this.tracks = null;
            }
        }
    }
    static fromJS(data, _mappings) {
        data = typeof data === 'object' ? data : {};
        return createInstance(data, _mappings, PlaylistModel);
    }
    toJSON(data) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : null;
        data["name"] = this.name !== undefined ? this.name : null;
        data["author"] = this.author !== undefined ? this.author : null;
        data["image"] = this.image !== undefined ? this.image : null;
        data["rating"] = this.rating !== undefined ? this.rating : null;
        data["language"] = this.language !== undefined ? this.language : null;
        data["nation"] = this.nation !== undefined ? this.nation : null;
        if (Array.isArray(this.genres)) {
            data["genres"] = [];
            for (let item of this.genres)
                data["genres"].push(item);
        }
        data["complete"] = this.complete !== undefined ? this.complete : null;
        data["isTemporary"] = this.isTemporary !== undefined ? this.isTemporary : null;
        if (Array.isArray(this.tracks)) {
            data["tracks"] = [];
            for (let item of this.tracks)
                data["tracks"].push(item.toJSON());
        }
        return data;
    }
    clone() {
        const json = this.toJSON();
        let result = new PlaylistModel();
        result.init(json);
        return result;
    }
}
export class UpdateRequestOfPlaylistModel {
    oldModel;
    newModel;
    constructor(data) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property) && this.hasOwnProperty(property))
                    this[property] = data[property];
            }
        }
    }
    init(_data, _mappings) {
        if (_data) {
            this.oldModel = _data["oldModel"] ? PlaylistModel.fromJS(_data["oldModel"], _mappings) : null;
            this.newModel = _data["newModel"] ? PlaylistModel.fromJS(_data["newModel"], _mappings) : null;
        }
    }
    static fromJS(data, _mappings) {
        data = typeof data === 'object' ? data : {};
        return createInstance(data, _mappings, UpdateRequestOfPlaylistModel);
    }
    toJSON(data) {
        data = typeof data === 'object' ? data : {};
        data["oldModel"] = this.oldModel ? this.oldModel.toJSON() : null;
        data["newModel"] = this.newModel ? this.newModel.toJSON() : null;
        return data;
    }
    clone() {
        const json = this.toJSON();
        let result = new UpdateRequestOfPlaylistModel();
        result.init(json);
        return result;
    }
}
export class RecipeModel {
    id;
    title;
    nation;
    imageUrl;
    difficulty;
    rating;
    course;
    mainIngredient;
    technique;
    preparationTime;
    cookingTime;
    totalTime;
    ingredients;
    formattedText;
    constructor(data) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property) && this.hasOwnProperty(property))
                    this[property] = data[property];
            }
        }
    }
    init(_data, _mappings) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : null;
            this.title = _data["title"] !== undefined ? _data["title"] : null;
            this.nation = _data["nation"] !== undefined ? _data["nation"] : null;
            this.imageUrl = _data["imageUrl"] !== undefined ? _data["imageUrl"] : null;
            this.difficulty = _data["difficulty"] !== undefined ? _data["difficulty"] : null;
            this.rating = _data["rating"] !== undefined ? _data["rating"] : null;
            this.course = _data["course"] !== undefined ? _data["course"] : null;
            this.mainIngredient = _data["mainIngredient"] !== undefined ? _data["mainIngredient"] : null;
            this.technique = _data["technique"] !== undefined ? _data["technique"] : null;
            this.preparationTime = _data["preparationTime"] !== undefined ? _data["preparationTime"] : null;
            this.cookingTime = _data["cookingTime"] !== undefined ? _data["cookingTime"] : null;
            this.totalTime = _data["totalTime"] !== undefined ? _data["totalTime"] : null;
            if (Array.isArray(_data["ingredients"])) {
                this.ingredients = [];
                for (let item of _data["ingredients"])
                    this.ingredients.push(IngredientModel.fromJS(item, _mappings));
            }
            else {
                this.ingredients = null;
            }
            this.formattedText = _data["formattedText"] !== undefined ? _data["formattedText"] : null;
        }
    }
    static fromJS(data, _mappings) {
        data = typeof data === 'object' ? data : {};
        return createInstance(data, _mappings, RecipeModel);
    }
    toJSON(data) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : null;
        data["title"] = this.title !== undefined ? this.title : null;
        data["nation"] = this.nation !== undefined ? this.nation : null;
        data["imageUrl"] = this.imageUrl !== undefined ? this.imageUrl : null;
        data["difficulty"] = this.difficulty !== undefined ? this.difficulty : null;
        data["rating"] = this.rating !== undefined ? this.rating : null;
        data["course"] = this.course !== undefined ? this.course : null;
        data["mainIngredient"] = this.mainIngredient !== undefined ? this.mainIngredient : null;
        data["technique"] = this.technique !== undefined ? this.technique : null;
        data["preparationTime"] = this.preparationTime !== undefined ? this.preparationTime : null;
        data["cookingTime"] = this.cookingTime !== undefined ? this.cookingTime : null;
        data["totalTime"] = this.totalTime !== undefined ? this.totalTime : null;
        if (Array.isArray(this.ingredients)) {
            data["ingredients"] = [];
            for (let item of this.ingredients)
                data["ingredients"].push(item.toJSON());
        }
        data["formattedText"] = this.formattedText !== undefined ? this.formattedText : null;
        return data;
    }
    clone() {
        const json = this.toJSON();
        let result = new RecipeModel();
        result.init(json);
        return result;
    }
}
export var Course;
(function (Course) {
    Course["Starter"] = "Starter";
    Course["Main"] = "Main";
    Course["Side"] = "Side";
    Course["Desert"] = "Desert";
    Course["Salad"] = "Salad";
    Course["Soup"] = "Soup";
    Course["Drink"] = "Drink";
    Course["Snack"] = "Snack";
})(Course || (Course = {}));
export var Ingredient;
(function (Ingredient) {
    Ingredient["Meat"] = "Meat";
    Ingredient["Noodles"] = "Noodles";
    Ingredient["Rice"] = "Rice";
    Ingredient["Bread"] = "Bread";
    Ingredient["Fish"] = "Fish";
    Ingredient["Vegetables"] = "Vegetables";
    Ingredient["Fruits"] = "Fruits";
    Ingredient["Sweets"] = "Sweets";
    Ingredient["Miscellaneous"] = "Miscellaneous";
})(Ingredient || (Ingredient = {}));
export var CookingTechnique;
(function (CookingTechnique) {
    CookingTechnique["Boiling"] = "Boiling";
    CookingTechnique["Baking"] = "Baking";
    CookingTechnique["Frying"] = "Frying";
    CookingTechnique["DeepFrying"] = "DeepFrying";
    CookingTechnique["Steaming"] = "Steaming";
    CookingTechnique["Mixed"] = "Mixed";
    CookingTechnique["Freezing"] = "Freezing";
    CookingTechnique["Grilling"] = "Grilling";
    CookingTechnique["Raw"] = "Raw";
})(CookingTechnique || (CookingTechnique = {}));
export class IngredientModel {
    id;
    recipeId;
    name;
    description;
    groupName;
    amount;
    measurement;
    order;
    constructor(data) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property) && this.hasOwnProperty(property))
                    this[property] = data[property];
            }
        }
    }
    init(_data, _mappings) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : null;
            this.recipeId = _data["recipeId"] !== undefined ? _data["recipeId"] : null;
            this.name = _data["name"] !== undefined ? _data["name"] : null;
            this.description = _data["description"] !== undefined ? _data["description"] : null;
            this.groupName = _data["groupName"] !== undefined ? _data["groupName"] : null;
            this.amount = _data["amount"] !== undefined ? _data["amount"] : null;
            this.measurement = _data["measurement"] !== undefined ? _data["measurement"] : null;
            this.order = _data["order"] !== undefined ? _data["order"] : null;
        }
    }
    static fromJS(data, _mappings) {
        data = typeof data === 'object' ? data : {};
        return createInstance(data, _mappings, IngredientModel);
    }
    toJSON(data) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : null;
        data["recipeId"] = this.recipeId !== undefined ? this.recipeId : null;
        data["name"] = this.name !== undefined ? this.name : null;
        data["description"] = this.description !== undefined ? this.description : null;
        data["groupName"] = this.groupName !== undefined ? this.groupName : null;
        data["amount"] = this.amount !== undefined ? this.amount : null;
        data["measurement"] = this.measurement !== undefined ? this.measurement : null;
        data["order"] = this.order !== undefined ? this.order : null;
        return data;
    }
    clone() {
        const json = this.toJSON();
        let result = new IngredientModel();
        result.init(json);
        return result;
    }
}
export var Measurement;
(function (Measurement) {
    Measurement["Mass"] = "Mass";
    Measurement["Volume"] = "Volume";
    Measurement["Size"] = "Size";
    Measurement["Pinch"] = "Pinch";
    Measurement["Piece"] = "Piece";
    Measurement["Unitless"] = "Unitless";
})(Measurement || (Measurement = {}));
function jsonParse(json, reviver) {
    json = JSON.parse(json, reviver);
    var byid = {};
    var refs = [];
    json = (function recurse(obj, prop, parent) {
        if (typeof obj !== 'object' || !obj)
            return obj;
        if ("$ref" in obj) {
            let ref = obj.$ref;
            if (ref in byid)
                return byid[ref];
            refs.push([parent, prop, ref]);
            return undefined;
        }
        else if ("$id" in obj) {
            let id = obj.$id;
            delete obj.$id;
            if ("$values" in obj)
                obj = obj.$values;
            byid[id] = obj;
        }
        if (Array.isArray(obj)) {
            obj = obj.map((v, i) => recurse(v, i, obj));
        }
        else {
            for (var p in obj) {
                if (obj.hasOwnProperty(p) && obj[p] && typeof obj[p] === 'object')
                    obj[p] = recurse(obj[p], p, obj);
            }
        }
        return obj;
    })(json);
    for (let i = 0; i < refs.length; i++) {
        const ref = refs[i];
        ref[0][ref[1]] = byid[ref[2]];
    }
    return json;
}
function createInstance(data, mappings, type) {
    if (!mappings)
        mappings = [];
    if (!data)
        return null;
    const mappingIndexName = "__mappingIndex";
    if (data[mappingIndexName])
        return mappings[data[mappingIndexName]].target;
    data[mappingIndexName] = mappings.length;
    let result = new type();
    mappings.push({ source: data, target: result });
    result.init(data, mappings);
    return result;
}
export class SwaggerException extends Error {
    message;
    status;
    response;
    headers;
    result;
    constructor(message, status, response, headers, result) {
        super();
        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }
    isSwaggerException = true;
    static isSwaggerException(obj) {
        return obj.isSwaggerException === true;
    }
}
function throwException(message, status, response, headers, result) {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new SwaggerException(message, status, response, headers, null);
}
