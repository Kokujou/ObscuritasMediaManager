/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.15.9.0 (NJsonSchema v10.6.8.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming
// @ts-nocheck
export class CleanupClient {
    http;
    baseUrl;
    jsonParseReviver = undefined;
    constructor(baseUrl, http) {
        this.http = http ? http : window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }
    getBrokenAudioTracks(signal) {
        let url_ = this.baseUrl + "/api/Cleanup/music";
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processGetBrokenAudioTracks(_response);
        });
    }
    processGetBrokenAudioTracks(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => _headers[k] = v);
        }
        ;
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (Array.isArray(resultData200)) {
                    result200 = [];
                    for (let item of resultData200)
                        result200.push(MusicModel.fromJS(item));
                }
                else {
                    result200 = null;
                }
                return result200;
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    cleanupMusic(trackHashes, signal) {
        let url_ = this.baseUrl + "/api/Cleanup/music";
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(trackHashes);
        let options_ = {
            body: content_,
            method: "DELETE",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processCleanupMusic(_response);
        });
    }
    processCleanupMusic(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => _headers[k] = v);
        }
        ;
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (Array.isArray(resultData200)) {
                    result200 = [];
                    for (let item of resultData200)
                        result200.push(item);
                }
                else {
                    result200 = null;
                }
                return result200;
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
}
export class FileClient {
    http;
    baseUrl;
    jsonParseReviver = undefined;
    constructor(baseUrl, http) {
        this.http = http ? http : window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }
    getVideo(videoPath, signal) {
        let url_ = this.baseUrl + "/api/File/video?";
        if (videoPath !== undefined && videoPath !== null)
            url_ += "videoPath=" + encodeURIComponent("" + videoPath) + "&";
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processGetVideo(_response);
        });
    }
    processGetVideo(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => _headers[k] = v);
        }
        ;
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    getAudio(audioPath, highCompatibility, signal) {
        let url_ = this.baseUrl + "/api/File/audio?";
        if (audioPath !== undefined && audioPath !== null)
            url_ += "audioPath=" + encodeURIComponent("" + audioPath) + "&";
        if (highCompatibility === null)
            throw new Error("The parameter 'highCompatibility' cannot be null.");
        else if (highCompatibility !== undefined)
            url_ += "highCompatibility=" + encodeURIComponent("" + highCompatibility) + "&";
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processGetAudio(_response);
        });
    }
    processGetAudio(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => _headers[k] = v);
        }
        ;
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    validate(fileUrls, signal) {
        let url_ = this.baseUrl + "/api/File/validate-files";
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(fileUrls);
        let options_ = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processValidate(_response);
        });
    }
    processValidate(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => _headers[k] = v);
        }
        ;
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
}
export class GenreClient {
    http;
    baseUrl;
    jsonParseReviver = undefined;
    constructor(baseUrl, http) {
        this.http = http ? http : window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }
    getAll(signal) {
        let url_ = this.baseUrl + "/api/Genre";
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processGetAll(_response);
        });
    }
    processGetAll(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => _headers[k] = v);
        }
        ;
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (Array.isArray(resultData200)) {
                    result200 = [];
                    for (let item of resultData200)
                        result200.push(GenreModel.fromJS(item));
                }
                else {
                    result200 = null;
                }
                return result200;
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
}
export class LoginClient {
    http;
    baseUrl;
    jsonParseReviver = undefined;
    constructor(baseUrl, http) {
        this.http = http ? http : window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }
    login(request, signal) {
        let url_ = this.baseUrl + "/api/Login";
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(request);
        let options_ = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processLogin(_response);
        });
    }
    processLogin(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => _headers[k] = v);
        }
        ;
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : null;
                return result200;
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
}
export class MediaClient {
    http;
    baseUrl;
    jsonParseReviver = undefined;
    constructor(baseUrl, http) {
        this.http = http ? http : window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }
    get(guid, signal) {
        let url_ = this.baseUrl + "/api/Media/{guid}";
        if (guid === undefined || guid === null)
            throw new Error("The parameter 'guid' must be defined.");
        url_ = url_.replace("{guid}", encodeURIComponent("" + guid));
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processGet(_response);
        });
    }
    processGet(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => _headers[k] = v);
        }
        ;
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = MediaModel.fromJS(resultData200);
                return result200;
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    getAll(type, signal) {
        let url_ = this.baseUrl + "/api/Media?";
        if (type !== undefined && type !== null)
            url_ += "type=" + encodeURIComponent("" + type) + "&";
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processGetAll(_response);
        });
    }
    processGetAll(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => _headers[k] = v);
        }
        ;
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (Array.isArray(resultData200)) {
                    result200 = [];
                    for (let item of resultData200)
                        result200.push(MediaModel.fromJS(item));
                }
                else {
                    result200 = null;
                }
                return result200;
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    batchCreateMedia(media, signal) {
        let url_ = this.baseUrl + "/api/Media";
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(media);
        let options_ = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processBatchCreateMedia(_response);
        });
    }
    processBatchCreateMedia(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => _headers[k] = v);
        }
        ;
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    updateMedia(media, signal) {
        let url_ = this.baseUrl + "/api/Media";
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(media);
        let options_ = {
            body: content_,
            method: "PUT",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processUpdateMedia(_response);
        });
    }
    processUpdateMedia(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => _headers[k] = v);
        }
        ;
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    addMediaImage(image, guid, signal) {
        let url_ = this.baseUrl + "/api/Media/{guid}/image";
        if (guid === undefined || guid === null)
            throw new Error("The parameter 'guid' must be defined.");
        url_ = url_.replace("{guid}", encodeURIComponent("" + guid));
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(image);
        let options_ = {
            body: content_,
            method: "PUT",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processAddMediaImage(_response);
        });
    }
    processAddMediaImage(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => _headers[k] = v);
        }
        ;
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    deleteMediaImage(guid, signal) {
        let url_ = this.baseUrl + "/api/Media/{guid}/image";
        if (guid === undefined || guid === null)
            throw new Error("The parameter 'guid' must be defined.");
        url_ = url_.replace("{guid}", encodeURIComponent("" + guid));
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "DELETE",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processDeleteMediaImage(_response);
        });
    }
    processDeleteMediaImage(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => _headers[k] = v);
        }
        ;
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
}
export class MusicClient {
    http;
    baseUrl;
    jsonParseReviver = undefined;
    constructor(baseUrl, http) {
        this.http = http ? http : window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }
    batchCreateMusicTracks(tracks, signal) {
        let url_ = this.baseUrl + "/api/Music";
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(tracks);
        let options_ = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processBatchCreateMusicTracks(_response);
        });
    }
    processBatchCreateMusicTracks(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => _headers[k] = v);
        }
        ;
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    getAll(signal) {
        let url_ = this.baseUrl + "/api/Music";
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processGetAll(_response);
        });
    }
    processGetAll(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => _headers[k] = v);
        }
        ;
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (Array.isArray(resultData200)) {
                    result200 = [];
                    for (let item of resultData200)
                        result200.push(MusicModel.fromJS(item));
                }
                else {
                    result200 = null;
                }
                return result200;
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    recalculateHashes(signal) {
        let url_ = this.baseUrl + "/api/Music/recalculate-hashes";
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "POST",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processRecalculateHashes(_response);
        });
    }
    processRecalculateHashes(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => _headers[k] = v);
        }
        ;
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    get(hash, signal) {
        let url_ = this.baseUrl + "/api/Music/{hash}";
        if (hash === undefined || hash === null)
            throw new Error("The parameter 'hash' must be defined.");
        url_ = url_.replace("{hash}", encodeURIComponent("" + hash));
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processGet(_response);
        });
    }
    processGet(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => _headers[k] = v);
        }
        ;
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = MusicModel.fromJS(resultData200);
                return result200;
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    update(hash, updateRequest, signal) {
        let url_ = this.baseUrl + "/api/Music/{hash}";
        if (hash === undefined || hash === null)
            throw new Error("The parameter 'hash' must be defined.");
        url_ = url_.replace("{hash}", encodeURIComponent("" + hash));
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(updateRequest);
        let options_ = {
            body: content_,
            method: "PUT",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processUpdate(_response);
        });
    }
    processUpdate(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => _headers[k] = v);
        }
        ;
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    getInstruments(signal) {
        let url_ = this.baseUrl + "/api/Music/instruments";
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processGetInstruments(_response);
        });
    }
    processGetInstruments(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => _headers[k] = v);
        }
        ;
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (Array.isArray(resultData200)) {
                    result200 = [];
                    for (let item of resultData200)
                        result200.push(InstrumentModel.fromJS(item));
                }
                else {
                    result200 = null;
                }
                return result200;
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    addInstrument(type, name, signal) {
        let url_ = this.baseUrl + "/api/Music/instrument/{name}/type/{type}";
        if (type === undefined || type === null)
            throw new Error("The parameter 'type' must be defined.");
        url_ = url_.replace("{type}", encodeURIComponent("" + type));
        if (name === undefined || name === null)
            throw new Error("The parameter 'name' must be defined.");
        url_ = url_.replace("{name}", encodeURIComponent("" + name));
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "PUT",
            signal,
            headers: {}
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processAddInstrument(_response);
        });
    }
    processAddInstrument(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => _headers[k] = v);
        }
        ;
        if (status === 200) {
            return response.text().then((_responseText) => {
                return;
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    removeInstrument(type, name, signal) {
        let url_ = this.baseUrl + "/api/Music/instrument/{name}/type/{type}";
        if (type === undefined || type === null)
            throw new Error("The parameter 'type' must be defined.");
        url_ = url_.replace("{type}", encodeURIComponent("" + type));
        if (name === undefined || name === null)
            throw new Error("The parameter 'name' must be defined.");
        url_ = url_.replace("{name}", encodeURIComponent("" + name));
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "DELETE",
            signal,
            headers: {}
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processRemoveInstrument(_response);
        });
    }
    processRemoveInstrument(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => _headers[k] = v);
        }
        ;
        if (status === 200) {
            return response.text().then((_responseText) => {
                return;
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
}
export class PlaylistClient {
    http;
    baseUrl;
    jsonParseReviver = undefined;
    constructor(baseUrl, http) {
        this.http = http ? http : window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }
    createTemporaryPlaylist(hashes, signal) {
        let url_ = this.baseUrl + "/api/Playlist/temp";
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(hashes);
        let options_ = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processCreateTemporaryPlaylist(_response);
        });
    }
    processCreateTemporaryPlaylist(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => _headers[k] = v);
        }
        ;
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : null;
                return result200;
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    listPlaylists(signal) {
        let url_ = this.baseUrl + "/api/Playlist/list";
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processListPlaylists(_response);
        });
    }
    processListPlaylists(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => _headers[k] = v);
        }
        ;
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (Array.isArray(resultData200)) {
                    result200 = [];
                    for (let item of resultData200)
                        result200.push(PlaylistModel.fromJS(item));
                }
                else {
                    result200 = null;
                }
                return result200;
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    getTemporaryPlaylist(guid, signal) {
        let url_ = this.baseUrl + "/api/Playlist/temp/{guid}";
        if (guid === undefined || guid === null)
            throw new Error("The parameter 'guid' must be defined.");
        url_ = url_.replace("{guid}", encodeURIComponent("" + guid));
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processGetTemporaryPlaylist(_response);
        });
    }
    processGetTemporaryPlaylist(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => _headers[k] = v);
        }
        ;
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (Array.isArray(resultData200)) {
                    result200 = [];
                    for (let item of resultData200)
                        result200.push(MusicModel.fromJS(item));
                }
                else {
                    result200 = null;
                }
                return result200;
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    getPlaylist(id, signal) {
        let url_ = this.baseUrl + "/api/Playlist/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processGetPlaylist(_response);
        });
    }
    processGetPlaylist(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => _headers[k] = v);
        }
        ;
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (Array.isArray(resultData200)) {
                    result200 = [];
                    for (let item of resultData200)
                        result200.push(MusicModel.fromJS(item));
                }
                else {
                    result200 = null;
                }
                return result200;
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    createPlaylist(name, trackHashes, signal) {
        let url_ = this.baseUrl + "/api/Playlist/create/{name}";
        if (name === undefined || name === null)
            throw new Error("The parameter 'name' must be defined.");
        url_ = url_.replace("{name}", encodeURIComponent("" + name));
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(trackHashes);
        let options_ = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
            }
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processCreatePlaylist(_response);
        });
    }
    processCreatePlaylist(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => _headers[k] = v);
        }
        ;
        if (status === 200) {
            return response.text().then((_responseText) => {
                return;
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
}
export class RecipeClient {
    http;
    baseUrl;
    jsonParseReviver = undefined;
    constructor(baseUrl, http) {
        this.http = http ? http : window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }
    getAllRecipes(signal) {
        let url_ = this.baseUrl + "/api/Recipe";
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processGetAllRecipes(_response);
        });
    }
    processGetAllRecipes(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => _headers[k] = v);
        }
        ;
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (Array.isArray(resultData200)) {
                    result200 = [];
                    for (let item of resultData200)
                        result200.push(RecipeModel.fromJS(item));
                }
                else {
                    result200 = null;
                }
                return result200;
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    createRecipe(recipe, signal) {
        let url_ = this.baseUrl + "/api/Recipe";
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(recipe);
        let options_ = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
            }
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processCreateRecipe(_response);
        });
    }
    processCreateRecipe(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => _headers[k] = v);
        }
        ;
        if (status === 200) {
            return response.text().then((_responseText) => {
                return;
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    updateRecipe(recipe, signal) {
        let url_ = this.baseUrl + "/api/Recipe";
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(recipe);
        let options_ = {
            body: content_,
            method: "PATCH",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processUpdateRecipe(_response);
        });
    }
    processUpdateRecipe(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => _headers[k] = v);
        }
        ;
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    getRecipe(id, signal) {
        let url_ = this.baseUrl + "/api/Recipe/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processGetRecipe(_response);
        });
    }
    processGetRecipe(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => _headers[k] = v);
        }
        ;
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = RecipeModel.fromJS(resultData200);
                return result200;
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
}
export class StreamingClient {
    http;
    baseUrl;
    jsonParseReviver = undefined;
    constructor(baseUrl, http) {
        this.http = http ? http : window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }
    batchPostStreamingEntries(streamingEntries, signal) {
        let url_ = this.baseUrl + "/api/Streaming";
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(streamingEntries);
        let options_ = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processBatchPostStreamingEntries(_response);
        });
    }
    processBatchPostStreamingEntries(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => _headers[k] = v);
        }
        ;
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    getStreamingEntries(guid, signal) {
        let url_ = this.baseUrl + "/api/Streaming/{guid}";
        if (guid === undefined || guid === null)
            throw new Error("The parameter 'guid' must be defined.");
        url_ = url_.replace("{guid}", encodeURIComponent("" + guid));
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processGetStreamingEntries(_response);
        });
    }
    processGetStreamingEntries(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => _headers[k] = v);
        }
        ;
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (Array.isArray(resultData200)) {
                    result200 = [];
                    for (let item of resultData200)
                        result200.push(StreamingEntryModel.fromJS(item));
                }
                else {
                    result200 = null;
                }
                return result200;
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    getStream(guid, season, episode, signal) {
        let url_ = this.baseUrl + "/api/Streaming/{guid}/season/{season}/episode/{episode}";
        if (guid === undefined || guid === null)
            throw new Error("The parameter 'guid' must be defined.");
        url_ = url_.replace("{guid}", encodeURIComponent("" + guid));
        if (season === undefined || season === null)
            throw new Error("The parameter 'season' must be defined.");
        url_ = url_.replace("{season}", encodeURIComponent("" + season));
        if (episode === undefined || episode === null)
            throw new Error("The parameter 'episode' must be defined.");
        url_ = url_.replace("{episode}", encodeURIComponent("" + episode));
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processGetStream(_response);
        });
    }
    processGetStream(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => _headers[k] = v);
        }
        ;
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = StreamingEntryModel.fromJS(resultData200);
                return result200;
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
}
export class MusicModel {
    name;
    author;
    source;
    mood1;
    mood2;
    language;
    nation;
    instrumentation;
    participants;
    instruments;
    genres;
    path;
    rating;
    complete;
    hash;
    constructor(data) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    this[property] = data[property];
            }
        }
    }
    init(_data) {
        if (_data) {
            this.name = _data["name"] !== undefined ? _data["name"] : null;
            this.author = _data["author"] !== undefined ? _data["author"] : null;
            this.source = _data["source"] !== undefined ? _data["source"] : null;
            this.mood1 = _data["mood1"] !== undefined ? _data["mood1"] : null;
            this.mood2 = _data["mood2"] !== undefined ? _data["mood2"] : null;
            this.language = _data["language"] !== undefined ? _data["language"] : null;
            this.nation = _data["nation"] !== undefined ? _data["nation"] : null;
            this.instrumentation = _data["instrumentation"] !== undefined ? _data["instrumentation"] : null;
            this.participants = _data["participants"] !== undefined ? _data["participants"] : null;
            if (Array.isArray(_data["instruments"])) {
                this.instruments = [];
                for (let item of _data["instruments"])
                    this.instruments.push(item);
            }
            else {
                this.instruments = null;
            }
            if (Array.isArray(_data["genres"])) {
                this.genres = [];
                for (let item of _data["genres"])
                    this.genres.push(item);
            }
            else {
                this.genres = null;
            }
            this.path = _data["path"] !== undefined ? _data["path"] : null;
            this.rating = _data["rating"] !== undefined ? _data["rating"] : null;
            this.complete = _data["complete"] !== undefined ? _data["complete"] : null;
            this.hash = _data["hash"] !== undefined ? _data["hash"] : null;
        }
    }
    static fromJS(data) {
        data = typeof data === 'object' ? data : {};
        let result = new MusicModel();
        result.init(data);
        return result;
    }
    toJSON(data) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name !== undefined ? this.name : null;
        data["author"] = this.author !== undefined ? this.author : null;
        data["source"] = this.source !== undefined ? this.source : null;
        data["mood1"] = this.mood1 !== undefined ? this.mood1 : null;
        data["mood2"] = this.mood2 !== undefined ? this.mood2 : null;
        data["language"] = this.language !== undefined ? this.language : null;
        data["nation"] = this.nation !== undefined ? this.nation : null;
        data["instrumentation"] = this.instrumentation !== undefined ? this.instrumentation : null;
        data["participants"] = this.participants !== undefined ? this.participants : null;
        if (Array.isArray(this.instruments)) {
            data["instruments"] = [];
            for (let item of this.instruments)
                data["instruments"].push(item);
        }
        if (Array.isArray(this.genres)) {
            data["genres"] = [];
            for (let item of this.genres)
                data["genres"].push(item);
        }
        data["path"] = this.path !== undefined ? this.path : null;
        data["rating"] = this.rating !== undefined ? this.rating : null;
        data["complete"] = this.complete !== undefined ? this.complete : null;
        data["hash"] = this.hash !== undefined ? this.hash : null;
        return data;
    }
    clone() {
        const json = this.toJSON();
        let result = new MusicModel();
        result.init(json);
        return result;
    }
}
export var Mood;
(function (Mood) {
    Mood["Unset"] = "Unset";
    Mood["Happy"] = "Happy";
    Mood["Aggressive"] = "Aggressive";
    Mood["Sad"] = "Sad";
    Mood["Cool"] = "Cool";
    Mood["Calm"] = "Calm";
    Mood["Romantic"] = "Romantic";
    Mood["Dramatic"] = "Dramatic";
    Mood["Epic"] = "Epic";
    Mood["Funny"] = "Funny";
    Mood["Passionate"] = "Passionate";
    Mood["Monotonuous"] = "Monotonuous";
})(Mood || (Mood = {}));
export var Nation;
(function (Nation) {
    Nation["Unset"] = "Unset";
    Nation["Japanese"] = "Japanese";
    Nation["English"] = "English";
    Nation["German"] = "German";
    Nation["Spain"] = "Spain";
    Nation["Chinese"] = "Chinese";
    Nation["Italian"] = "Italian";
    Nation["Russian"] = "Russian";
    Nation["SouthAmerican"] = "SouthAmerican";
    Nation["African"] = "African";
})(Nation || (Nation = {}));
export var Instrumentation;
(function (Instrumentation) {
    Instrumentation["Unset"] = "Unset";
    Instrumentation["Mono"] = "Mono";
    Instrumentation["Groups"] = "Groups";
    Instrumentation["Mixed"] = "Mixed";
})(Instrumentation || (Instrumentation = {}));
export var Participants;
(function (Participants) {
    Participants["Unset"] = "Unset";
    Participants["Solo"] = "Solo";
    Participants["SmallGroup"] = "SmallGroup";
    Participants["LargeGroup"] = "LargeGroup";
    Participants["SmallOrchestra"] = "SmallOrchestra";
    Participants["LargeOrchestra"] = "LargeOrchestra";
})(Participants || (Participants = {}));
export var MusicGenre;
(function (MusicGenre) {
    MusicGenre["Unset"] = "Unset";
    MusicGenre["Acapella"] = "Acapella";
    MusicGenre["Avantgarde"] = "Avantgarde";
    MusicGenre["Blues"] = "Blues";
    MusicGenre["Classic"] = "Classic";
    MusicGenre["Comedy"] = "Comedy";
    MusicGenre["Country"] = "Country";
    MusicGenre["EasyListening"] = "EasyListening";
    MusicGenre["Electronic"] = "Electronic";
    MusicGenre["House"] = "House";
    MusicGenre["Flamenco"] = "Flamenco";
    MusicGenre["Folk"] = "Folk";
    MusicGenre["Jazz"] = "Jazz";
    MusicGenre["Latin"] = "Latin";
    MusicGenre["Pop"] = "Pop";
    MusicGenre["RnB"] = "RnB";
    MusicGenre["Soul"] = "Soul";
    MusicGenre["Rock"] = "Rock";
    MusicGenre["Metal"] = "Metal";
    MusicGenre["March"] = "March";
    MusicGenre["Moe"] = "Moe";
    MusicGenre["Wagakki"] = "Wagakki";
    MusicGenre["Medley"] = "Medley";
    MusicGenre["Parody"] = "Parody";
    MusicGenre["Ballad"] = "Ballad";
    MusicGenre["FilmMusic"] = "FilmMusic";
    MusicGenre["Western"] = "Western";
    MusicGenre["Christmas"] = "Christmas";
})(MusicGenre || (MusicGenre = {}));
export class GenreModel {
    id;
    section;
    name;
    constructor(data) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    this[property] = data[property];
            }
        }
    }
    init(_data) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : null;
            this.section = _data["section"] !== undefined ? _data["section"] : null;
            this.name = _data["name"] !== undefined ? _data["name"] : null;
        }
    }
    static fromJS(data) {
        data = typeof data === 'object' ? data : {};
        let result = new GenreModel();
        result.init(data);
        return result;
    }
    toJSON(data) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : null;
        data["section"] = this.section !== undefined ? this.section : null;
        data["name"] = this.name !== undefined ? this.name : null;
        return data;
    }
    clone() {
        const json = this.toJSON();
        let result = new GenreModel();
        result.init(json);
        return result;
    }
}
export class CredentialsRequest {
    username;
    password;
    constructor(data) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    this[property] = data[property];
            }
        }
    }
    init(_data) {
        if (_data) {
            this.username = _data["username"] !== undefined ? _data["username"] : null;
            this.password = _data["password"] !== undefined ? _data["password"] : null;
        }
    }
    static fromJS(data) {
        data = typeof data === 'object' ? data : {};
        let result = new CredentialsRequest();
        result.init(data);
        return result;
    }
    toJSON(data) {
        data = typeof data === 'object' ? data : {};
        data["username"] = this.username !== undefined ? this.username : null;
        data["password"] = this.password !== undefined ? this.password : null;
        return data;
    }
    clone() {
        const json = this.toJSON();
        let result = new CredentialsRequest();
        result.init(json);
        return result;
    }
}
export class MediaModel {
    id;
    name;
    type;
    rating;
    release;
    genres;
    state;
    description;
    image;
    constructor(data) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    this[property] = data[property];
            }
        }
    }
    init(_data) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : null;
            this.name = _data["name"] !== undefined ? _data["name"] : null;
            this.type = _data["type"] !== undefined ? _data["type"] : null;
            this.rating = _data["rating"] !== undefined ? _data["rating"] : null;
            this.release = _data["release"] !== undefined ? _data["release"] : null;
            if (Array.isArray(_data["genres"])) {
                this.genres = [];
                for (let item of _data["genres"])
                    this.genres.push(item);
            }
            else {
                this.genres = null;
            }
            this.state = _data["state"] !== undefined ? _data["state"] : null;
            this.description = _data["description"] !== undefined ? _data["description"] : null;
            this.image = _data["image"] !== undefined ? _data["image"] : null;
        }
    }
    static fromJS(data) {
        data = typeof data === 'object' ? data : {};
        let result = new MediaModel();
        result.init(data);
        return result;
    }
    toJSON(data) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : null;
        data["name"] = this.name !== undefined ? this.name : null;
        data["type"] = this.type !== undefined ? this.type : null;
        data["rating"] = this.rating !== undefined ? this.rating : null;
        data["release"] = this.release !== undefined ? this.release : null;
        if (Array.isArray(this.genres)) {
            data["genres"] = [];
            for (let item of this.genres)
                data["genres"].push(item);
        }
        data["state"] = this.state !== undefined ? this.state : null;
        data["description"] = this.description !== undefined ? this.description : null;
        data["image"] = this.image !== undefined ? this.image : null;
        return data;
    }
    clone() {
        const json = this.toJSON();
        let result = new MediaModel();
        result.init(json);
        return result;
    }
}
export class InstrumentModel {
    name;
    type;
    constructor(data) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    this[property] = data[property];
            }
        }
    }
    init(_data) {
        if (_data) {
            this.name = _data["name"] !== undefined ? _data["name"] : null;
            this.type = _data["type"] !== undefined ? _data["type"] : null;
        }
    }
    static fromJS(data) {
        data = typeof data === 'object' ? data : {};
        let result = new InstrumentModel();
        result.init(data);
        return result;
    }
    toJSON(data) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name !== undefined ? this.name : null;
        data["type"] = this.type !== undefined ? this.type : null;
        return data;
    }
    clone() {
        const json = this.toJSON();
        let result = new InstrumentModel();
        result.init(json);
        return result;
    }
}
export var InstrumentType;
(function (InstrumentType) {
    InstrumentType["Unset"] = "Unset";
    InstrumentType["Vocal"] = "Vocal";
    InstrumentType["WoodWind"] = "WoodWind";
    InstrumentType["Brass"] = "Brass";
    InstrumentType["Percussion"] = "Percussion";
    InstrumentType["Stringed"] = "Stringed";
    InstrumentType["Keyboard"] = "Keyboard";
    InstrumentType["Electronic"] = "Electronic";
    InstrumentType["HumanBody"] = "HumanBody";
    InstrumentType["Miscellaneous"] = "Miscellaneous";
})(InstrumentType || (InstrumentType = {}));
export class UpdateRequestOfMusicModel {
    oldModel;
    newModel;
    constructor(data) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    this[property] = data[property];
            }
        }
    }
    init(_data) {
        if (_data) {
            this.oldModel = _data["oldModel"] ? MusicModel.fromJS(_data["oldModel"]) : null;
            this.newModel = _data["newModel"] ? MusicModel.fromJS(_data["newModel"]) : null;
        }
    }
    static fromJS(data) {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateRequestOfMusicModel();
        result.init(data);
        return result;
    }
    toJSON(data) {
        data = typeof data === 'object' ? data : {};
        data["oldModel"] = this.oldModel ? this.oldModel.toJSON() : null;
        data["newModel"] = this.newModel ? this.newModel.toJSON() : null;
        return data;
    }
    clone() {
        const json = this.toJSON();
        let result = new UpdateRequestOfMusicModel();
        result.init(json);
        return result;
    }
}
export class PlaylistModel {
    id;
    name;
    autor;
    image;
    rating;
    complete;
    genres;
    constructor(data) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    this[property] = data[property];
            }
        }
    }
    init(_data) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : null;
            this.name = _data["name"] !== undefined ? _data["name"] : null;
            this.autor = _data["autor"] !== undefined ? _data["autor"] : null;
            this.image = _data["image"] !== undefined ? _data["image"] : null;
            this.rating = _data["rating"] !== undefined ? _data["rating"] : null;
            this.complete = _data["complete"] !== undefined ? _data["complete"] : null;
            if (Array.isArray(_data["genres"])) {
                this.genres = [];
                for (let item of _data["genres"])
                    this.genres.push(item);
            }
            else {
                this.genres = null;
            }
        }
    }
    static fromJS(data) {
        data = typeof data === 'object' ? data : {};
        let result = new PlaylistModel();
        result.init(data);
        return result;
    }
    toJSON(data) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : null;
        data["name"] = this.name !== undefined ? this.name : null;
        data["autor"] = this.autor !== undefined ? this.autor : null;
        data["image"] = this.image !== undefined ? this.image : null;
        data["rating"] = this.rating !== undefined ? this.rating : null;
        data["complete"] = this.complete !== undefined ? this.complete : null;
        if (Array.isArray(this.genres)) {
            data["genres"] = [];
            for (let item of this.genres)
                data["genres"].push(item);
        }
        return data;
    }
    clone() {
        const json = this.toJSON();
        let result = new PlaylistModel();
        result.init(json);
        return result;
    }
}
export class RecipeModel {
    id;
    title;
    nation;
    imageUrl;
    difficulty;
    rating;
    course;
    mainIngredient;
    technique;
    preparationTime;
    cookingTime;
    totalTime;
    ingredients;
    formattedText;
    constructor(data) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    this[property] = data[property];
            }
        }
    }
    init(_data) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : null;
            this.title = _data["title"] !== undefined ? _data["title"] : null;
            this.nation = _data["nation"] !== undefined ? _data["nation"] : null;
            this.imageUrl = _data["imageUrl"] !== undefined ? _data["imageUrl"] : null;
            this.difficulty = _data["difficulty"] !== undefined ? _data["difficulty"] : null;
            this.rating = _data["rating"] !== undefined ? _data["rating"] : null;
            this.course = _data["course"] !== undefined ? _data["course"] : null;
            this.mainIngredient = _data["mainIngredient"] !== undefined ? _data["mainIngredient"] : null;
            this.technique = _data["technique"] !== undefined ? _data["technique"] : null;
            this.preparationTime = _data["preparationTime"] !== undefined ? _data["preparationTime"] : null;
            this.cookingTime = _data["cookingTime"] !== undefined ? _data["cookingTime"] : null;
            this.totalTime = _data["totalTime"] !== undefined ? _data["totalTime"] : null;
            if (Array.isArray(_data["ingredients"])) {
                this.ingredients = [];
                for (let item of _data["ingredients"])
                    this.ingredients.push(IngredientModel.fromJS(item));
            }
            else {
                this.ingredients = null;
            }
            this.formattedText = _data["formattedText"] !== undefined ? _data["formattedText"] : null;
        }
    }
    static fromJS(data) {
        data = typeof data === 'object' ? data : {};
        let result = new RecipeModel();
        result.init(data);
        return result;
    }
    toJSON(data) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : null;
        data["title"] = this.title !== undefined ? this.title : null;
        data["nation"] = this.nation !== undefined ? this.nation : null;
        data["imageUrl"] = this.imageUrl !== undefined ? this.imageUrl : null;
        data["difficulty"] = this.difficulty !== undefined ? this.difficulty : null;
        data["rating"] = this.rating !== undefined ? this.rating : null;
        data["course"] = this.course !== undefined ? this.course : null;
        data["mainIngredient"] = this.mainIngredient !== undefined ? this.mainIngredient : null;
        data["technique"] = this.technique !== undefined ? this.technique : null;
        data["preparationTime"] = this.preparationTime !== undefined ? this.preparationTime : null;
        data["cookingTime"] = this.cookingTime !== undefined ? this.cookingTime : null;
        data["totalTime"] = this.totalTime !== undefined ? this.totalTime : null;
        if (Array.isArray(this.ingredients)) {
            data["ingredients"] = [];
            for (let item of this.ingredients)
                data["ingredients"].push(item.toJSON());
        }
        data["formattedText"] = this.formattedText !== undefined ? this.formattedText : null;
        return data;
    }
    clone() {
        const json = this.toJSON();
        let result = new RecipeModel();
        result.init(json);
        return result;
    }
}
export var Course;
(function (Course) {
    Course["Starter"] = "Starter";
    Course["Main"] = "Main";
    Course["Side"] = "Side";
    Course["Desert"] = "Desert";
    Course["Salad"] = "Salad";
    Course["Soup"] = "Soup";
    Course["Drink"] = "Drink";
    Course["Snack"] = "Snack";
})(Course || (Course = {}));
export var Ingredient;
(function (Ingredient) {
    Ingredient["Meat"] = "Meat";
    Ingredient["Noodles"] = "Noodles";
    Ingredient["Rice"] = "Rice";
    Ingredient["Bread"] = "Bread";
    Ingredient["Fish"] = "Fish";
    Ingredient["Vegetables"] = "Vegetables";
    Ingredient["Fruits"] = "Fruits";
    Ingredient["Sweets"] = "Sweets";
    Ingredient["Miscellaneous"] = "Miscellaneous";
})(Ingredient || (Ingredient = {}));
export var CookingTechnique;
(function (CookingTechnique) {
    CookingTechnique["Boiling"] = "Boiling";
    CookingTechnique["Baking"] = "Baking";
    CookingTechnique["Frying"] = "Frying";
    CookingTechnique["DeepFrying"] = "DeepFrying";
    CookingTechnique["Steaming"] = "Steaming";
    CookingTechnique["Mixed"] = "Mixed";
    CookingTechnique["Freezing"] = "Freezing";
    CookingTechnique["Grilling"] = "Grilling";
    CookingTechnique["Raw"] = "Raw";
})(CookingTechnique || (CookingTechnique = {}));
export class IngredientModel {
    id;
    recipeId;
    name;
    description;
    groupName;
    amount;
    measurement;
    order;
    constructor(data) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    this[property] = data[property];
            }
        }
    }
    init(_data) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : null;
            this.recipeId = _data["recipeId"] !== undefined ? _data["recipeId"] : null;
            this.name = _data["name"] !== undefined ? _data["name"] : null;
            this.description = _data["description"] !== undefined ? _data["description"] : null;
            this.groupName = _data["groupName"] !== undefined ? _data["groupName"] : null;
            this.amount = _data["amount"] !== undefined ? _data["amount"] : null;
            this.measurement = _data["measurement"] !== undefined ? _data["measurement"] : null;
            this.order = _data["order"] !== undefined ? _data["order"] : null;
        }
    }
    static fromJS(data) {
        data = typeof data === 'object' ? data : {};
        let result = new IngredientModel();
        result.init(data);
        return result;
    }
    toJSON(data) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : null;
        data["recipeId"] = this.recipeId !== undefined ? this.recipeId : null;
        data["name"] = this.name !== undefined ? this.name : null;
        data["description"] = this.description !== undefined ? this.description : null;
        data["groupName"] = this.groupName !== undefined ? this.groupName : null;
        data["amount"] = this.amount !== undefined ? this.amount : null;
        data["measurement"] = this.measurement !== undefined ? this.measurement : null;
        data["order"] = this.order !== undefined ? this.order : null;
        return data;
    }
    clone() {
        const json = this.toJSON();
        let result = new IngredientModel();
        result.init(json);
        return result;
    }
}
export var Measurement;
(function (Measurement) {
    Measurement["Mass"] = "Mass";
    Measurement["Volume"] = "Volume";
    Measurement["Size"] = "Size";
    Measurement["Pinch"] = "Pinch";
    Measurement["Piece"] = "Piece";
    Measurement["Unitless"] = "Unitless";
})(Measurement || (Measurement = {}));
export class StreamingEntryModel {
    id;
    season;
    episode;
    src;
    constructor(data) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    this[property] = data[property];
            }
        }
    }
    init(_data) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : null;
            this.season = _data["season"] !== undefined ? _data["season"] : null;
            this.episode = _data["episode"] !== undefined ? _data["episode"] : null;
            this.src = _data["src"] !== undefined ? _data["src"] : null;
        }
    }
    static fromJS(data) {
        data = typeof data === 'object' ? data : {};
        let result = new StreamingEntryModel();
        result.init(data);
        return result;
    }
    toJSON(data) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : null;
        data["season"] = this.season !== undefined ? this.season : null;
        data["episode"] = this.episode !== undefined ? this.episode : null;
        data["src"] = this.src !== undefined ? this.src : null;
        return data;
    }
    clone() {
        const json = this.toJSON();
        let result = new StreamingEntryModel();
        result.init(json);
        return result;
    }
}
export class SwaggerException extends Error {
    message;
    status;
    response;
    headers;
    result;
    constructor(message, status, response, headers, result) {
        super();
        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }
    isSwaggerException = true;
    static isSwaggerException(obj) {
        return obj.isSwaggerException === true;
    }
}
function throwException(message, status, response, headers, result) {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new SwaggerException(message, status, response, headers, null);
}
