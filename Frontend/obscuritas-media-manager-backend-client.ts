//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

export class CleanupClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "https://localhost/ObscuritasMediaManager/Backend";
    }

    getBrokenAudioTracks(signal?: AbortSignal): Promise<MusicModel[]> {
        let url_ = this.baseUrl + "/api/Cleanup/music";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetBrokenAudioTracks(_response);
        });
    }

    protected processGetBrokenAudioTracks(response: Response): Promise<MusicModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(MusicModel.fromJS(item, _mappings));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<MusicModel[]>(null as any);
    }

    validateMediaRoot(rootPath: string, signal?: AbortSignal): Promise<boolean> {
        let url_ = this.baseUrl + "/api/Cleanup/validate-media-root";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(rootPath);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processValidateMediaRoot(_response);
        });
    }

    protected processValidateMediaRoot(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }
}

export class FileClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "https://localhost/ObscuritasMediaManager/Backend";
    }

    getVideo(videoPath?: string | undefined, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/File/video?";
        if (videoPath === null)
            throw new Error("The parameter 'videoPath' cannot be null.");
        else if (videoPath !== undefined)
            url_ += "videoPath=" + encodeURIComponent("" + videoPath) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetVideo(_response);
        });
    }

    protected processGetVideo(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }

    getAudio(audioPath?: string | undefined, highCompatibility?: boolean | undefined, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/File/audio?";
        if (audioPath === null)
            throw new Error("The parameter 'audioPath' cannot be null.");
        else if (audioPath !== undefined)
            url_ += "audioPath=" + encodeURIComponent("" + audioPath) + "&";
        if (highCompatibility === null)
            throw new Error("The parameter 'highCompatibility' cannot be null.");
        else if (highCompatibility !== undefined)
            url_ += "highCompatibility=" + encodeURIComponent("" + highCompatibility) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAudio(_response);
        });
    }

    protected processGetAudio(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }

    validate(fileUrls: string[], signal?: AbortSignal): Promise<boolean> {
        let url_ = this.baseUrl + "/api/File/validate-files";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(fileUrls);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processValidate(_response);
        });
    }

    protected processValidate(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }
}

export class GenreClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "https://localhost/ObscuritasMediaManager/Backend";
    }

    getAll(signal?: AbortSignal): Promise<MediaGenreModel[]> {
        let url_ = this.baseUrl + "/api/Genre";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: Response): Promise<MediaGenreModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(MediaGenreModel.fromJS(item, _mappings));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<MediaGenreModel[]>(null as any);
    }

    addGenre(section: MediaGenreCategory, name: string, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/Genre/section/{section}/name/{name}";
        if (section === undefined || section === null)
            throw new Error("The parameter 'section' must be defined.");
        url_ = url_.replace("{section}", encodeURIComponent("" + section));
        if (name === undefined || name === null)
            throw new Error("The parameter 'name' must be defined.");
        url_ = url_.replace("{name}", encodeURIComponent("" + name));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "PUT",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAddGenre(_response);
        });
    }

    protected processAddGenre(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    removeGenre(id: string, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/Genre/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRemoveGenre(_response);
        });
    }

    protected processRemoveGenre(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class InteropProxyClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "https://localhost/ObscuritasMediaManager/Backend";
    }

    connectToInterop(signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/InteropProxy";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processConnectToInterop(_response);
        });
    }

    protected processConnectToInterop(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class LoginClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "https://localhost/ObscuritasMediaManager/Backend";
    }

    login(request: CredentialsRequest, signal?: AbortSignal): Promise<string> {
        let url_ = this.baseUrl + "/api/Login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processLogin(_response);
        });
    }

    protected processLogin(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }
}

export class MediaClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "https://localhost/ObscuritasMediaManager/Backend";
    }

    getDefault(signal?: AbortSignal): Promise<MediaModel> {
        let url_ = this.baseUrl + "/api/Media/default";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetDefault(_response);
        });
    }

    protected processGetDefault(response: Response): Promise<MediaModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = MediaModel.fromJS(resultData200, _mappings);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<MediaModel>(null as any);
    }

    get(guid: string, signal?: AbortSignal): Promise<MediaModel> {
        let url_ = this.baseUrl + "/api/Media/{guid}";
        if (guid === undefined || guid === null)
            throw new Error("The parameter 'guid' must be defined.");
        url_ = url_.replace("{guid}", encodeURIComponent("" + guid));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<MediaModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = MediaModel.fromJS(resultData200, _mappings);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<MediaModel>(null as any);
    }

    getImageFor(guid: string, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/Media/{guid}/image";
        if (guid === undefined || guid === null)
            throw new Error("The parameter 'guid' must be defined.");
        url_ = url_.replace("{guid}", encodeURIComponent("" + guid));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetImageFor(_response);
        });
    }

    protected processGetImageFor(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }

    addMediaImage(image: string, guid: string, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/Media/{guid}/image";
        if (guid === undefined || guid === null)
            throw new Error("The parameter 'guid' must be defined.");
        url_ = url_.replace("{guid}", encodeURIComponent("" + guid));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(image);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            signal,
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAddMediaImage(_response);
        });
    }

    protected processAddMediaImage(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    deleteMediaImage(guid: string, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/Media/{guid}/image";
        if (guid === undefined || guid === null)
            throw new Error("The parameter 'guid' must be defined.");
        url_ = url_.replace("{guid}", encodeURIComponent("" + guid));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteMediaImage(_response);
        });
    }

    protected processDeleteMediaImage(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getAll(signal?: AbortSignal): Promise<MediaModel[]> {
        let url_ = this.baseUrl + "/api/Media";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: Response): Promise<MediaModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(MediaModel.fromJS(item, _mappings));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<MediaModel[]>(null as any);
    }

    createFromMediaPath(request: MediaCreationRequest, signal?: AbortSignal): Promise<KeyValuePairOfNullableGuidAndModelCreationState> {
        let url_ = this.baseUrl + "/api/Media";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateFromMediaPath(_response);
        });
    }

    protected processCreateFromMediaPath(response: Response): Promise<KeyValuePairOfNullableGuidAndModelCreationState> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = KeyValuePairOfNullableGuidAndModelCreationState.fromJS(resultData200, _mappings);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<KeyValuePairOfNullableGuidAndModelCreationState>(null as any);
    }

    updateMedia(id: string, _: UpdateRequestOfObject, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/Media/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(_);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            signal,
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateMedia(_response);
        });
    }

    protected processUpdateMedia(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    hardDeleteMedium(mediaId: string, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/Media/{mediaId}/hard";
        if (mediaId === undefined || mediaId === null)
            throw new Error("The parameter 'mediaId' must be defined.");
        url_ = url_.replace("{mediaId}", encodeURIComponent("" + mediaId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processHardDeleteMedium(_response);
        });
    }

    protected processHardDeleteMedium(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    fullDeleteMedium(mediaId: string, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/Media/{mediaId}/full";
        if (mediaId === undefined || mediaId === null)
            throw new Error("The parameter 'mediaId' must be defined.");
        url_ = url_.replace("{mediaId}", encodeURIComponent("" + mediaId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFullDeleteMedium(_response);
        });
    }

    protected processFullDeleteMedium(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    autoFillMediaDetails(animeId: string, signal?: AbortSignal): Promise<MediaModel> {
        let url_ = this.baseUrl + "/api/Media/auto-fill-anime-details/{animeId}";
        if (animeId === undefined || animeId === null)
            throw new Error("The parameter 'animeId' must be defined.");
        url_ = url_.replace("{animeId}", encodeURIComponent("" + animeId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAutoFillMediaDetails(_response);
        });
    }

    protected processAutoFillMediaDetails(response: Response): Promise<MediaModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = MediaModel.fromJS(resultData200, _mappings);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<MediaModel>(null as any);
    }
}

export class MusicClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "https://localhost/ObscuritasMediaManager/Backend";
    }

    getDefault(signal?: AbortSignal): Promise<MusicModel> {
        let url_ = this.baseUrl + "/api/Music/default";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetDefault(_response);
        });
    }

    protected processGetDefault(response: Response): Promise<MusicModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = MusicModel.fromJS(resultData200, _mappings);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<MusicModel>(null as any);
    }

    createMusicTrack(track: MusicModel, signal?: AbortSignal): Promise<string> {
        let url_ = this.baseUrl + "/api/Music/track";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(track);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateMusicTrack(_response);
        });
    }

    protected processCreateMusicTrack(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }

    createMusicTrackFromPath(trackPath: string, signal?: AbortSignal): Promise<KeyValuePairOfStringAndModelCreationState> {
        let url_ = this.baseUrl + "/api/Music/tracks";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(trackPath);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateMusicTrackFromPath(_response);
        });
    }

    protected processCreateMusicTrackFromPath(response: Response): Promise<KeyValuePairOfStringAndModelCreationState> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = KeyValuePairOfStringAndModelCreationState.fromJS(resultData200, _mappings);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<KeyValuePairOfStringAndModelCreationState>(null as any);
    }

    recalculateHashes(signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/Music/recalculate-hashes";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRecalculateHashes(_response);
        });
    }

    protected processRecalculateHashes(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getAll(signal?: AbortSignal): Promise<MusicModel[]> {
        let url_ = this.baseUrl + "/api/Music";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: Response): Promise<MusicModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(MusicModel.fromJS(item, _mappings));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<MusicModel[]>(null as any);
    }

    get(hash: string, signal?: AbortSignal): Promise<MusicModel> {
        let url_ = this.baseUrl + "/api/Music/{hash}";
        if (hash === undefined || hash === null)
            throw new Error("The parameter 'hash' must be defined.");
        url_ = url_.replace("{hash}", encodeURIComponent("" + hash));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<MusicModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = MusicModel.fromJS(resultData200, _mappings);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<MusicModel>(null as any);
    }

    update(hash: string, _: UpdateRequestOfObject, signal?: AbortSignal): Promise<MusicModel> {
        let url_ = this.baseUrl + "/api/Music/{hash}";
        if (hash === undefined || hash === null)
            throw new Error("The parameter 'hash' must be defined.");
        url_ = url_.replace("{hash}", encodeURIComponent("" + hash));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(_);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: Response): Promise<MusicModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = MusicModel.fromJS(resultData200, _mappings);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<MusicModel>(null as any);
    }

    getLyrics(hash: string, offset?: number | undefined, signal?: AbortSignal): Promise<LyricsResponse> {
        let url_ = this.baseUrl + "/api/Music/{hash}/lyrics?";
        if (hash === undefined || hash === null)
            throw new Error("The parameter 'hash' must be defined.");
        url_ = url_.replace("{hash}", encodeURIComponent("" + hash));
        if (offset === null)
            throw new Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "offset=" + encodeURIComponent("" + offset) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetLyrics(_response);
        });
    }

    protected processGetLyrics(response: Response): Promise<LyricsResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = LyricsResponse.fromJS(resultData200, _mappings);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<LyricsResponse>(null as any);
    }

    getInstruments(signal?: AbortSignal): Promise<InstrumentModel[]> {
        let url_ = this.baseUrl + "/api/Music/instruments";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetInstruments(_response);
        });
    }

    protected processGetInstruments(response: Response): Promise<InstrumentModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(InstrumentModel.fromJS(item, _mappings));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<InstrumentModel[]>(null as any);
    }

    addInstrument(type: InstrumentType, name: string, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/Music/instrument/{name}/type/{type}";
        if (type === undefined || type === null)
            throw new Error("The parameter 'type' must be defined.");
        url_ = url_.replace("{type}", encodeURIComponent("" + type));
        if (name === undefined || name === null)
            throw new Error("The parameter 'name' must be defined.");
        url_ = url_.replace("{name}", encodeURIComponent("" + name));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "PUT",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAddInstrument(_response);
        });
    }

    protected processAddInstrument(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    removeInstrument(type: InstrumentType, name: string, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/Music/instrument/{name}/type/{type}";
        if (type === undefined || type === null)
            throw new Error("The parameter 'type' must be defined.");
        url_ = url_.replace("{type}", encodeURIComponent("" + type));
        if (name === undefined || name === null)
            throw new Error("The parameter 'name' must be defined.");
        url_ = url_.replace("{name}", encodeURIComponent("" + name));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRemoveInstrument(_response);
        });
    }

    protected processRemoveInstrument(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    softDeleteTracks(trackHashes: string[], signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/Music/music/soft";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(trackHashes);

        let options_: RequestInit = {
            body: content_,
            method: "DELETE",
            signal,
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSoftDeleteTracks(_response);
        });
    }

    protected processSoftDeleteTracks(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    undeleteTracks(trackHashes: string[], signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/Music/music/undelete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(trackHashes);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            signal,
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUndeleteTracks(_response);
        });
    }

    protected processUndeleteTracks(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    hardDeleteTracks(trackHashes: string[], signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/Music/music/hard";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(trackHashes);

        let options_: RequestInit = {
            body: content_,
            method: "DELETE",
            signal,
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processHardDeleteTracks(_response);
        });
    }

    protected processHardDeleteTracks(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class PlaylistClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "https://localhost/ObscuritasMediaManager/Backend";
    }

    getDummyPlaylist(signal?: AbortSignal): Promise<PlaylistModel> {
        let url_ = this.baseUrl + "/api/Playlist/dummy";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetDummyPlaylist(_response);
        });
    }

    protected processGetDummyPlaylist(response: Response): Promise<PlaylistModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = PlaylistModel.fromJS(resultData200, _mappings);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PlaylistModel>(null as any);
    }

    createTemporaryPlaylist(hashes: string[], signal?: AbortSignal): Promise<string> {
        let url_ = this.baseUrl + "/api/Playlist/temp";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(hashes);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateTemporaryPlaylist(_response);
        });
    }

    protected processCreateTemporaryPlaylist(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }

    getPlaylist(playlistId: string, signal?: AbortSignal): Promise<PlaylistModel> {
        let url_ = this.baseUrl + "/api/Playlist/{playlistId}";
        if (playlistId === undefined || playlistId === null)
            throw new Error("The parameter 'playlistId' must be defined.");
        url_ = url_.replace("{playlistId}", encodeURIComponent("" + playlistId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetPlaylist(_response);
        });
    }

    protected processGetPlaylist(response: Response): Promise<PlaylistModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = PlaylistModel.fromJS(resultData200, _mappings);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PlaylistModel>(null as any);
    }

    updatePlaylistData(playlistId: string, updateRequest: UpdateRequestOfPlaylistModel, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/Playlist/{playlistId}";
        if (playlistId === undefined || playlistId === null)
            throw new Error("The parameter 'playlistId' must be defined.");
        url_ = url_.replace("{playlistId}", encodeURIComponent("" + playlistId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateRequest);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            signal,
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdatePlaylistData(_response);
        });
    }

    protected processUpdatePlaylistData(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    deletePlaylist(playlistId: string, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/Playlist/{playlistId}";
        if (playlistId === undefined || playlistId === null)
            throw new Error("The parameter 'playlistId' must be defined.");
        url_ = url_.replace("{playlistId}", encodeURIComponent("" + playlistId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeletePlaylist(_response);
        });
    }

    protected processDeletePlaylist(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    listPlaylists(signal?: AbortSignal): Promise<PlaylistModel[]> {
        let url_ = this.baseUrl + "/api/Playlist/list";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processListPlaylists(_response);
        });
    }

    protected processListPlaylists(response: Response): Promise<PlaylistModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PlaylistModel.fromJS(item, _mappings));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PlaylistModel[]>(null as any);
    }

    createPlaylist(playlist: PlaylistModel, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/Playlist/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(playlist);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreatePlaylist(_response);
        });
    }

    protected processCreatePlaylist(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    addTracksToPlaylist(playlistId: string, trackHashes: string[], signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/Playlist/{playlistId}/tracks";
        if (playlistId === undefined || playlistId === null)
            throw new Error("The parameter 'playlistId' must be defined.");
        url_ = url_.replace("{playlistId}", encodeURIComponent("" + playlistId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(trackHashes);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            signal,
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAddTracksToPlaylist(_response);
        });
    }

    protected processAddTracksToPlaylist(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class RecipeClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "https://localhost/ObscuritasMediaManager/Backend";
    }

    getAllRecipes(signal?: AbortSignal): Promise<RecipeModelBase[]> {
        let url_ = this.baseUrl + "/api/Recipe";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllRecipes(_response);
        });
    }

    protected processGetAllRecipes(response: Response): Promise<RecipeModelBase[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(RecipeModelBase.fromJS(item, _mappings));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<RecipeModelBase[]>(null as any);
    }

    createRecipe(recipe: RecipeModel, signal?: AbortSignal): Promise<string> {
        let url_ = this.baseUrl + "/api/Recipe";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(recipe);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateRecipe(_response);
        });
    }

    protected processCreateRecipe(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }

    updateRecipe(recipe: RecipeModel, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/Recipe";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(recipe);

        let options_: RequestInit = {
            body: content_,
            method: "PATCH",
            signal,
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateRecipe(_response);
        });
    }

    protected processUpdateRecipe(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getRecipeImage(recipeId: string, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/Recipe/{recipeId}/image";
        if (recipeId === undefined || recipeId === null)
            throw new Error("The parameter 'recipeId' must be defined.");
        url_ = url_.replace("{recipeId}", encodeURIComponent("" + recipeId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetRecipeImage(_response);
        });
    }

    protected processGetRecipeImage(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }

    getRecipeThumb(recipeId: string, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/Recipe/{recipeId}/thumb";
        if (recipeId === undefined || recipeId === null)
            throw new Error("The parameter 'recipeId' must be defined.");
        url_ = url_.replace("{recipeId}", encodeURIComponent("" + recipeId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetRecipeThumb(_response);
        });
    }

    protected processGetRecipeThumb(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }

    searchDishes(search?: string | undefined, signal?: AbortSignal): Promise<RecipeModelBase[]> {
        let url_ = this.baseUrl + "/api/Recipe/search-dishes?";
        if (search === null)
            throw new Error("The parameter 'search' cannot be null.");
        else if (search !== undefined)
            url_ += "search=" + encodeURIComponent("" + search) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSearchDishes(_response);
        });
    }

    protected processSearchDishes(response: Response): Promise<RecipeModelBase[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(RecipeModelBase.fromJS(item, _mappings));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<RecipeModelBase[]>(null as any);
    }

    getRecipe(id: string, signal?: AbortSignal): Promise<RecipeModelBase> {
        let url_ = this.baseUrl + "/api/Recipe/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetRecipe(_response);
        });
    }

    protected processGetRecipe(response: Response): Promise<RecipeModelBase> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = RecipeModelBase.fromJS(resultData200, _mappings);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<RecipeModelBase>(null as any);
    }

    importDish(dish: FoodModel, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/Recipe/dish";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dish);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            signal,
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processImportDish(_response);
        });
    }

    protected processImportDish(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getIngredients(signal?: AbortSignal): Promise<IngredientModel[]> {
        let url_ = this.baseUrl + "/api/Recipe/ingredients";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetIngredients(_response);
        });
    }

    protected processGetIngredients(response: Response): Promise<IngredientModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(IngredientModel.fromJS(item, _mappings));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<IngredientModel[]>(null as any);
    }

    searchIngredients(search: string, maxItems?: number | undefined, signal?: AbortSignal): Promise<IngredientModel[]> {
        let url_ = this.baseUrl + "/api/Recipe/ingredients/search/{search}?";
        if (search === undefined || search === null)
            throw new Error("The parameter 'search' must be defined.");
        url_ = url_.replace("{search}", encodeURIComponent("" + search));
        if (maxItems === null)
            throw new Error("The parameter 'maxItems' cannot be null.");
        else if (maxItems !== undefined)
            url_ += "maxItems=" + encodeURIComponent("" + maxItems) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSearchIngredients(_response);
        });
    }

    protected processSearchIngredients(response: Response): Promise<IngredientModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(IngredientModel.fromJS(item, _mappings));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<IngredientModel[]>(null as any);
    }

    addIngredient(recipeId: string, ingredient: RecipeIngredientMappingModel, signal?: AbortSignal): Promise<string> {
        let url_ = this.baseUrl + "/api/Recipe/{recipeId}/ingredient";
        if (recipeId === undefined || recipeId === null)
            throw new Error("The parameter 'recipeId' must be defined.");
        url_ = url_.replace("{recipeId}", encodeURIComponent("" + recipeId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(ingredient);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAddIngredient(_response);
        });
    }

    protected processAddIngredient(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }

    updateIngredient(ingredientName: string, ingredient: IngredientModel, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/Recipe/ingredient/{ingredientName}";
        if (ingredientName === undefined || ingredientName === null)
            throw new Error("The parameter 'ingredientName' must be defined.");
        url_ = url_.replace("{ingredientName}", encodeURIComponent("" + ingredientName));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(ingredient);

        let options_: RequestInit = {
            body: content_,
            method: "PATCH",
            signal,
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateIngredient(_response);
        });
    }

    protected processUpdateIngredient(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    deleteIngredient(recipeId: string, ingredientId: string, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/Recipe/{recipeId}/ingredient/{ingredientId}";
        if (recipeId === undefined || recipeId === null)
            throw new Error("The parameter 'recipeId' must be defined.");
        url_ = url_.replace("{recipeId}", encodeURIComponent("" + recipeId));
        if (ingredientId === undefined || ingredientId === null)
            throw new Error("The parameter 'ingredientId' must be defined.");
        url_ = url_.replace("{ingredientId}", encodeURIComponent("" + ingredientId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteIngredient(_response);
        });
    }

    protected processDeleteIngredient(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    searchCookware(search: string, maxItems?: number | undefined, signal?: AbortSignal): Promise<string[]> {
        let url_ = this.baseUrl + "/api/Recipe/cookware/search?";
        if (maxItems === null)
            throw new Error("The parameter 'maxItems' cannot be null.");
        else if (maxItems !== undefined)
            url_ += "maxItems=" + encodeURIComponent("" + maxItems) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(search);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSearchCookware(_response);
        });
    }

    protected processSearchCookware(response: Response): Promise<string[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string[]>(null as any);
    }

    addCookware(recipeId: string, cookware: RecipeCookwareMappingModel, signal?: AbortSignal): Promise<string> {
        let url_ = this.baseUrl + "/api/Recipe/{recipeId}/cookware";
        if (recipeId === undefined || recipeId === null)
            throw new Error("The parameter 'recipeId' must be defined.");
        url_ = url_.replace("{recipeId}", encodeURIComponent("" + recipeId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(cookware);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAddCookware(_response);
        });
    }

    protected processAddCookware(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }

    deleteCookware(recipeId: string, cookwareId: string, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/Recipe/{recipeId}/cookware/{cookwareId}";
        if (recipeId === undefined || recipeId === null)
            throw new Error("The parameter 'recipeId' must be defined.");
        url_ = url_.replace("{recipeId}", encodeURIComponent("" + recipeId));
        if (cookwareId === undefined || cookwareId === null)
            throw new Error("The parameter 'cookwareId' must be defined.");
        url_ = url_.replace("{cookwareId}", encodeURIComponent("" + cookwareId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteCookware(_response);
        });
    }

    protected processDeleteCookware(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    softDeleteRecipe(recipeId: string, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/Recipe/{recipeId}/soft";
        if (recipeId === undefined || recipeId === null)
            throw new Error("The parameter 'recipeId' must be defined.");
        url_ = url_.replace("{recipeId}", encodeURIComponent("" + recipeId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSoftDeleteRecipe(_response);
        });
    }

    protected processSoftDeleteRecipe(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    undeleteRecipe(recipeId: string, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/Recipe/{recipeId}/undelete";
        if (recipeId === undefined || recipeId === null)
            throw new Error("The parameter 'recipeId' must be defined.");
        url_ = url_.replace("{recipeId}", encodeURIComponent("" + recipeId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUndeleteRecipe(_response);
        });
    }

    protected processUndeleteRecipe(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    hardDeleteRecipe(recipeId: string, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/Recipe/{recipeId}/hard";
        if (recipeId === undefined || recipeId === null)
            throw new Error("The parameter 'recipeId' must be defined.");
        url_ = url_.replace("{recipeId}", encodeURIComponent("" + recipeId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processHardDeleteRecipe(_response);
        });
    }

    protected processHardDeleteRecipe(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class MusicModel implements IMusicModel {
    name!: string;
    displayName!: string;
    author!: string | null;
    source!: string | null;
    mood1!: Mood;
    mood2!: Mood;
    language!: Language;
    instrumentation!: Instrumentation;
    participants!: Participants;
    instruments!: InstrumentModel[];
    instrumentTypes!: InstrumentType[];
    instrumentNames!: string[];
    genres!: MusicGenre[];
    path!: string;
    lyrics!: string | null;
    rating!: number;
    complete!: boolean;
    hash!: string;
    deleted!: boolean;

    constructor(data?: Partial<IMusicModel>) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property) && this.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }

        if (!data) {
            this.instruments = [];
            this.instrumentTypes = [];
            this.instrumentNames = [];
            this.genres = [];
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.displayName = _data["displayName"] !== undefined ? _data["displayName"] : <any>null;
            this.author = _data["author"] !== undefined ? _data["author"] : <any>null;
            this.source = _data["source"] !== undefined ? _data["source"] : <any>null;
            this.mood1 = _data["mood1"] !== undefined ? _data["mood1"] : <any>null;
            this.mood2 = _data["mood2"] !== undefined ? _data["mood2"] : <any>null;
            this.language = _data["language"] !== undefined ? _data["language"] : <any>null;
            this.instrumentation = _data["instrumentation"] !== undefined ? _data["instrumentation"] : <any>null;
            this.participants = _data["participants"] !== undefined ? _data["participants"] : <any>null;
            if (Array.isArray(_data["instruments"])) {
                this.instruments = [] as any;
                for (let item of _data["instruments"])
                    this.instruments!.push(InstrumentModel.fromJS(item, _mappings));
            }
            else {
                this.instruments = <any>null;
            }
            if (Array.isArray(_data["instrumentTypes"])) {
                this.instrumentTypes = [] as any;
                for (let item of _data["instrumentTypes"])
                    this.instrumentTypes!.push(item);
            }
            else {
                this.instrumentTypes = <any>null;
            }
            if (Array.isArray(_data["instrumentNames"])) {
                this.instrumentNames = [] as any;
                for (let item of _data["instrumentNames"])
                    this.instrumentNames!.push(item);
            }
            else {
                this.instrumentNames = <any>null;
            }
            if (Array.isArray(_data["genres"])) {
                this.genres = [] as any;
                for (let item of _data["genres"])
                    this.genres!.push(item);
            }
            else {
                this.genres = <any>null;
            }
            this.path = _data["path"] !== undefined ? _data["path"] : <any>null;
            this.lyrics = _data["lyrics"] !== undefined ? _data["lyrics"] : <any>null;
            this.rating = _data["rating"] !== undefined ? _data["rating"] : <any>null;
            this.complete = _data["complete"] !== undefined ? _data["complete"] : <any>null;
            this.hash = _data["hash"] !== undefined ? _data["hash"] : <any>null;
            this.deleted = _data["deleted"] !== undefined ? _data["deleted"] : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): MusicModel  {
        data = typeof data === 'object' ? data : {};
        return createInstance<MusicModel>(data, _mappings, MusicModel)!;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["displayName"] = this.displayName !== undefined ? this.displayName : <any>null;
        data["author"] = this.author !== undefined ? this.author : <any>null;
        data["source"] = this.source !== undefined ? this.source : <any>null;
        data["mood1"] = this.mood1 !== undefined ? this.mood1 : <any>null;
        data["mood2"] = this.mood2 !== undefined ? this.mood2 : <any>null;
        data["language"] = this.language !== undefined ? this.language : <any>null;
        data["instrumentation"] = this.instrumentation !== undefined ? this.instrumentation : <any>null;
        data["participants"] = this.participants !== undefined ? this.participants : <any>null;
        if (Array.isArray(this.instruments)) {
            data["instruments"] = [];
            for (let item of this.instruments)
                data["instruments"].push(item.toJSON());
        }
        if (Array.isArray(this.instrumentTypes)) {
            data["instrumentTypes"] = [];
            for (let item of this.instrumentTypes)
                data["instrumentTypes"].push(item);
        }
        if (Array.isArray(this.instrumentNames)) {
            data["instrumentNames"] = [];
            for (let item of this.instrumentNames)
                data["instrumentNames"].push(item);
        }
        if (Array.isArray(this.genres)) {
            data["genres"] = [];
            for (let item of this.genres)
                data["genres"].push(item);
        }
        data["path"] = this.path !== undefined ? this.path : <any>null;
        data["lyrics"] = this.lyrics !== undefined ? this.lyrics : <any>null;
        data["rating"] = this.rating !== undefined ? this.rating : <any>null;
        data["complete"] = this.complete !== undefined ? this.complete : <any>null;
        data["hash"] = this.hash !== undefined ? this.hash : <any>null;
        data["deleted"] = this.deleted !== undefined ? this.deleted : <any>null;
        return data;
    }

    clone(): MusicModel {
        const json = this.toJSON();
        let result = new MusicModel();
        result.init(json);
        return result;
    }
}

export interface IMusicModel {
    name: string;
    displayName: string;
    author: string | null;
    source: string | null;
    mood1: Mood;
    mood2: Mood;
    language: Language;
    instrumentation: Instrumentation;
    participants: Participants;
    instruments: InstrumentModel[];
    instrumentTypes: InstrumentType[];
    instrumentNames: string[];
    genres: MusicGenre[];
    path: string;
    lyrics: string | null;
    rating: number;
    complete: boolean;
    hash: string;
    deleted: boolean;
}

export enum Mood {
    Unset = "Unset",
    Happy = "Happy",
    Aggressive = "Aggressive",
    Sad = "Sad",
    Cool = "Cool",
    Calm = "Calm",
    Romantic = "Romantic",
    Dramatic = "Dramatic",
    Epic = "Epic",
    Funny = "Funny",
    Passionate = "Passionate",
    Monotonuous = "Monotonuous",
}

export enum Language {
    Unset = "Unset",
    Japanese = "Japanese",
    English = "English",
    German = "German",
    Spain = "Spain",
    Chinese = "Chinese",
    Italian = "Italian",
    Russian = "Russian",
    SouthAmerican = "SouthAmerican",
    African = "African",
    Korean = "Korean",
}

export enum Instrumentation {
    Unset = "Unset",
    Mono = "Mono",
    Groups = "Groups",
    Mixed = "Mixed",
}

export enum Participants {
    Unset = "Unset",
    Solo = "Solo",
    SmallGroup = "SmallGroup",
    LargeGroup = "LargeGroup",
    SmallOrchestra = "SmallOrchestra",
    LargeOrchestra = "LargeOrchestra",
}

export class InstrumentModel implements IInstrumentModel {
    id!: number;
    name!: string;
    type!: InstrumentType;

    constructor(data?: Partial<IInstrumentModel>) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property) && this.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }

    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.type = _data["type"] !== undefined ? _data["type"] : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): InstrumentModel  {
        data = typeof data === 'object' ? data : {};
        return createInstance<InstrumentModel>(data, _mappings, InstrumentModel)!;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["type"] = this.type !== undefined ? this.type : <any>null;
        return data;
    }

    clone(): InstrumentModel {
        const json = this.toJSON();
        let result = new InstrumentModel();
        result.init(json);
        return result;
    }
}

export interface IInstrumentModel {
    id: number;
    name: string;
    type: InstrumentType;
}

export enum InstrumentType {
    Unset = "Unset",
    Vocal = "Vocal",
    WoodWind = "WoodWind",
    Brass = "Brass",
    Percussion = "Percussion",
    Stringed = "Stringed",
    Keyboard = "Keyboard",
    Electronic = "Electronic",
    HumanBody = "HumanBody",
    Miscellaneous = "Miscellaneous",
}

export enum MusicGenre {
    Unset = "Unset",
    Acapella = "Acapella",
    Avantgarde = "Avantgarde",
    Blues = "Blues",
    Classic = "Classic",
    Comedy = "Comedy",
    Country = "Country",
    EasyListening = "EasyListening",
    Electronic = "Electronic",
    Flamenco = "Flamenco",
    Folk = "Folk",
    HipHop = "HipHop",
    House = "House",
    Instrumental = "Instrumental",
    Jazz = "Jazz",
    Latin = "Latin",
    Pop = "Pop",
    RnB = "RnB",
    Soul = "Soul",
    Rock = "Rock",
    Metal = "Metal",
    March = "March",
    Moe = "Moe",
    Wagakki = "Wagakki",
    Medley = "Medley",
    Parody = "Parody",
    Ballad = "Ballad",
    FilmMusic = "FilmMusic",
    Western = "Western",
    Christmas = "Christmas",
    Enka = "Enka",
}

export class GenreModel implements IGenreModel {
    id!: string;
    name!: string;
    sectionName!: string;

    constructor(data?: Partial<IGenreModel>) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property) && this.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }

    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.sectionName = _data["sectionName"] !== undefined ? _data["sectionName"] : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): GenreModel  {
        data = typeof data === 'object' ? data : {};
        return createInstance<GenreModel>(data, _mappings, GenreModel)!;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["sectionName"] = this.sectionName !== undefined ? this.sectionName : <any>null;
        return data;
    }

    clone(): GenreModel {
        const json = this.toJSON();
        let result = new GenreModel();
        result.init(json);
        return result;
    }
}

export interface IGenreModel {
    id: string;
    name: string;
    sectionName: string;
}

export class MediaGenreModel extends GenreModel implements IMediaGenreModel {
    section!: MediaGenreCategory;

    constructor(data?: Partial<IMediaGenreModel>) {
        super(data);
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property) && this.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }

    }

    init(_data?: any, _mappings?: any) {
        super.init(_data);
        if (_data) {
            this.section = _data["section"] !== undefined ? _data["section"] : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): MediaGenreModel  {
        data = typeof data === 'object' ? data : {};
        return createInstance<MediaGenreModel>(data, _mappings, MediaGenreModel)!;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["section"] = this.section !== undefined ? this.section : <any>null;
        super.toJSON(data);
        return data;
    }

    clone(): MediaGenreModel {
        const json = this.toJSON();
        let result = new MediaGenreModel();
        result.init(json);
        return result;
    }
}

export interface IMediaGenreModel extends IGenreModel {
    section: MediaGenreCategory;
}

export enum MediaGenreCategory {
    Relationship = "Relationship",
    Plot = "Plot",
    MainGenre = "MainGenre",
    JobsOrHobbies = "JobsOrHobbies",
    Battle = "Battle",
    Art = "Art",
    Location = "Location",
    Personalities = "Personalities",
    Protagonist = "Protagonist",
    School = "School",
    Sports = "Sports",
    Style = "Style",
    Beings = "Beings",
    Era = "Era",
    Mood = "Mood",
}

export class CredentialsRequest implements ICredentialsRequest {
    username!: string;
    password!: string;

    constructor(data?: Partial<ICredentialsRequest>) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property) && this.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }

    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.username = _data["username"] !== undefined ? _data["username"] : <any>null;
            this.password = _data["password"] !== undefined ? _data["password"] : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): CredentialsRequest  {
        data = typeof data === 'object' ? data : {};
        return createInstance<CredentialsRequest>(data, _mappings, CredentialsRequest)!;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["username"] = this.username !== undefined ? this.username : <any>null;
        data["password"] = this.password !== undefined ? this.password : <any>null;
        return data;
    }

    clone(): CredentialsRequest {
        const json = this.toJSON();
        let result = new CredentialsRequest();
        result.init(json);
        return result;
    }
}

export interface ICredentialsRequest {
    username: string;
    password: string;
}

export class MediaModel implements IMediaModel {
    contentWarnings!: ContentWarning[];
    description!: string | null;
    genres!: MediaGenreModel[];
    hash!: string;
    name!: string;
    romajiName!: string | null;
    kanjiName!: string | null;
    germanName!: string | null;
    englishName!: string | null;
    id!: string;
    language!: Language;
    rating!: number;
    release!: number;
    status!: MediaStatus;
    targetGroup!: TargetGroup;
    type!: MediaCategory;
    rootFolderPath!: string;
    deleted!: boolean;
    complete!: boolean;

    constructor(data?: Partial<IMediaModel>) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property) && this.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }

        if (!data) {
            this.contentWarnings = [];
            this.genres = [];
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            if (Array.isArray(_data["contentWarnings"])) {
                this.contentWarnings = [] as any;
                for (let item of _data["contentWarnings"])
                    this.contentWarnings!.push(item);
            }
            else {
                this.contentWarnings = <any>null;
            }
            this.description = _data["description"] !== undefined ? _data["description"] : <any>null;
            if (Array.isArray(_data["genres"])) {
                this.genres = [] as any;
                for (let item of _data["genres"])
                    this.genres!.push(MediaGenreModel.fromJS(item, _mappings));
            }
            else {
                this.genres = <any>null;
            }
            this.hash = _data["hash"] !== undefined ? _data["hash"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.romajiName = _data["romajiName"] !== undefined ? _data["romajiName"] : <any>null;
            this.kanjiName = _data["kanjiName"] !== undefined ? _data["kanjiName"] : <any>null;
            this.germanName = _data["germanName"] !== undefined ? _data["germanName"] : <any>null;
            this.englishName = _data["englishName"] !== undefined ? _data["englishName"] : <any>null;
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.language = _data["language"] !== undefined ? _data["language"] : <any>null;
            this.rating = _data["rating"] !== undefined ? _data["rating"] : <any>null;
            this.release = _data["release"] !== undefined ? _data["release"] : <any>null;
            this.status = _data["status"] !== undefined ? _data["status"] : <any>null;
            this.targetGroup = _data["targetGroup"] !== undefined ? _data["targetGroup"] : <any>null;
            this.type = _data["type"] !== undefined ? _data["type"] : <any>null;
            this.rootFolderPath = _data["rootFolderPath"] !== undefined ? _data["rootFolderPath"] : <any>null;
            this.deleted = _data["deleted"] !== undefined ? _data["deleted"] : <any>null;
            this.complete = _data["complete"] !== undefined ? _data["complete"] : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): MediaModel  {
        data = typeof data === 'object' ? data : {};
        return createInstance<MediaModel>(data, _mappings, MediaModel)!;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.contentWarnings)) {
            data["contentWarnings"] = [];
            for (let item of this.contentWarnings)
                data["contentWarnings"].push(item);
        }
        data["description"] = this.description !== undefined ? this.description : <any>null;
        if (Array.isArray(this.genres)) {
            data["genres"] = [];
            for (let item of this.genres)
                data["genres"].push(item.toJSON());
        }
        data["hash"] = this.hash !== undefined ? this.hash : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["romajiName"] = this.romajiName !== undefined ? this.romajiName : <any>null;
        data["kanjiName"] = this.kanjiName !== undefined ? this.kanjiName : <any>null;
        data["germanName"] = this.germanName !== undefined ? this.germanName : <any>null;
        data["englishName"] = this.englishName !== undefined ? this.englishName : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["language"] = this.language !== undefined ? this.language : <any>null;
        data["rating"] = this.rating !== undefined ? this.rating : <any>null;
        data["release"] = this.release !== undefined ? this.release : <any>null;
        data["status"] = this.status !== undefined ? this.status : <any>null;
        data["targetGroup"] = this.targetGroup !== undefined ? this.targetGroup : <any>null;
        data["type"] = this.type !== undefined ? this.type : <any>null;
        data["rootFolderPath"] = this.rootFolderPath !== undefined ? this.rootFolderPath : <any>null;
        data["deleted"] = this.deleted !== undefined ? this.deleted : <any>null;
        data["complete"] = this.complete !== undefined ? this.complete : <any>null;
        return data;
    }

    clone(): MediaModel {
        const json = this.toJSON();
        let result = new MediaModel();
        result.init(json);
        return result;
    }
}

export interface IMediaModel {
    contentWarnings: ContentWarning[];
    description: string | null;
    genres: MediaGenreModel[];
    hash: string;
    name: string;
    romajiName: string | null;
    kanjiName: string | null;
    germanName: string | null;
    englishName: string | null;
    id: string;
    language: Language;
    rating: number;
    release: number;
    status: MediaStatus;
    targetGroup: TargetGroup;
    type: MediaCategory;
    rootFolderPath: string;
    deleted: boolean;
    complete: boolean;
}

export enum ContentWarning {
    Depression = "Depression",
    Drugs = "Drugs",
    Violence = "Violence",
    Horror = "Horror",
    Gore = "Gore",
    Vulgarity = "Vulgarity",
    Sexuality = "Sexuality",
}

export enum MediaStatus {
    Completed = "Completed",
    Airing = "Airing",
    PreAiring = "PreAiring",
    Aborted = "Aborted",
    Incomplete = "Incomplete",
}

export enum TargetGroup {
    Children = "Children",
    Adolescents = "Adolescents",
    Adults = "Adults",
    Families = "Families",
    Men = "Men",
    Women = "Women",
    None = "None",
}

export enum MediaCategory {
    AnimeSeries = "AnimeSeries",
    AnimeMovies = "AnimeMovies",
    RealMovies = "RealMovies",
    RealSeries = "RealSeries",
    JDrama = "JDrama",
}

export class KeyValuePairOfNullableGuidAndModelCreationState implements IKeyValuePairOfNullableGuidAndModelCreationState {
    key!: string | null;
    value!: ModelCreationState;

    constructor(data?: Partial<IKeyValuePairOfNullableGuidAndModelCreationState>) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property) && this.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }

    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.key = _data["key"] !== undefined ? _data["key"] : <any>null;
            this.value = _data["value"] !== undefined ? _data["value"] : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): KeyValuePairOfNullableGuidAndModelCreationState  {
        data = typeof data === 'object' ? data : {};
        return createInstance<KeyValuePairOfNullableGuidAndModelCreationState>(data, _mappings, KeyValuePairOfNullableGuidAndModelCreationState)!;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key !== undefined ? this.key : <any>null;
        data["value"] = this.value !== undefined ? this.value : <any>null;
        return data;
    }

    clone(): KeyValuePairOfNullableGuidAndModelCreationState {
        const json = this.toJSON();
        let result = new KeyValuePairOfNullableGuidAndModelCreationState();
        result.init(json);
        return result;
    }
}

export interface IKeyValuePairOfNullableGuidAndModelCreationState {
    key: string | null;
    value: ModelCreationState;
}

export enum ModelCreationState {
    Loading = "Loading",
    Success = "Success",
    Updated = "Updated",
    Ignored = "Ignored",
    Invalid = "Invalid",
    Error = "Error",
}

export class MediaCreationRequest implements IMediaCreationRequest {
    rootPath!: string;
    category!: MediaCategory;
    language!: Language;
    entry!: MediaModel | null;

    constructor(data?: Partial<IMediaCreationRequest>) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property) && this.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }

    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.rootPath = _data["rootPath"] !== undefined ? _data["rootPath"] : <any>null;
            this.category = _data["category"] !== undefined ? _data["category"] : <any>null;
            this.language = _data["language"] !== undefined ? _data["language"] : <any>null;
            this.entry = _data["entry"] ? MediaModel.fromJS(_data["entry"], _mappings) : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): MediaCreationRequest  {
        data = typeof data === 'object' ? data : {};
        return createInstance<MediaCreationRequest>(data, _mappings, MediaCreationRequest)!;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["rootPath"] = this.rootPath !== undefined ? this.rootPath : <any>null;
        data["category"] = this.category !== undefined ? this.category : <any>null;
        data["language"] = this.language !== undefined ? this.language : <any>null;
        data["entry"] = this.entry ? this.entry.toJSON() : <any>null;
        return data;
    }

    clone(): MediaCreationRequest {
        const json = this.toJSON();
        let result = new MediaCreationRequest();
        result.init(json);
        return result;
    }
}

export interface IMediaCreationRequest {
    rootPath: string;
    category: MediaCategory;
    language: Language;
    entry: MediaModel | null;
}

export class UpdateRequestOfObject implements IUpdateRequestOfObject {
    oldModel!: any | null;
    newModel!: any | null;

    constructor(data?: Partial<IUpdateRequestOfObject>) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property) && this.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }

    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.oldModel = _data["oldModel"] !== undefined ? _data["oldModel"] : <any>null;
            this.newModel = _data["newModel"] !== undefined ? _data["newModel"] : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): UpdateRequestOfObject  {
        data = typeof data === 'object' ? data : {};
        return createInstance<UpdateRequestOfObject>(data, _mappings, UpdateRequestOfObject)!;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["oldModel"] = this.oldModel !== undefined ? this.oldModel : <any>null;
        data["newModel"] = this.newModel !== undefined ? this.newModel : <any>null;
        return data;
    }

    clone(): UpdateRequestOfObject {
        const json = this.toJSON();
        let result = new UpdateRequestOfObject();
        result.init(json);
        return result;
    }
}

export interface IUpdateRequestOfObject {
    oldModel: any | null;
    newModel: any | null;
}

export class KeyValuePairOfStringAndModelCreationState implements IKeyValuePairOfStringAndModelCreationState {
    key!: string | null;
    value!: ModelCreationState;

    constructor(data?: Partial<IKeyValuePairOfStringAndModelCreationState>) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property) && this.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }

    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.key = _data["key"] !== undefined ? _data["key"] : <any>null;
            this.value = _data["value"] !== undefined ? _data["value"] : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): KeyValuePairOfStringAndModelCreationState  {
        data = typeof data === 'object' ? data : {};
        return createInstance<KeyValuePairOfStringAndModelCreationState>(data, _mappings, KeyValuePairOfStringAndModelCreationState)!;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key !== undefined ? this.key : <any>null;
        data["value"] = this.value !== undefined ? this.value : <any>null;
        return data;
    }

    clone(): KeyValuePairOfStringAndModelCreationState {
        const json = this.toJSON();
        let result = new KeyValuePairOfStringAndModelCreationState();
        result.init(json);
        return result;
    }
}

export interface IKeyValuePairOfStringAndModelCreationState {
    key: string | null;
    value: ModelCreationState;
}

export class LyricsResponse implements ILyricsResponse {
    title!: string;
    text!: string;

    constructor(data?: Partial<ILyricsResponse>) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property) && this.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }

    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.title = _data["title"] !== undefined ? _data["title"] : <any>null;
            this.text = _data["text"] !== undefined ? _data["text"] : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): LyricsResponse  {
        data = typeof data === 'object' ? data : {};
        return createInstance<LyricsResponse>(data, _mappings, LyricsResponse)!;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title !== undefined ? this.title : <any>null;
        data["text"] = this.text !== undefined ? this.text : <any>null;
        return data;
    }

    clone(): LyricsResponse {
        const json = this.toJSON();
        let result = new LyricsResponse();
        result.init(json);
        return result;
    }
}

export interface ILyricsResponse {
    title: string;
    text: string;
}

export class PlaylistModel implements IPlaylistModel {
    id!: string;
    name!: string;
    author!: string | null;
    image!: string | null;
    rating!: number;
    language!: Language;
    nation!: Language;
    genres!: MusicGenre[];
    complete!: boolean;
    isTemporary!: boolean;
    tracks!: MusicModel[];

    constructor(data?: Partial<IPlaylistModel>) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property) && this.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }

        if (!data) {
            this.genres = [];
            this.tracks = [];
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.author = _data["author"] !== undefined ? _data["author"] : <any>null;
            this.image = _data["image"] !== undefined ? _data["image"] : <any>null;
            this.rating = _data["rating"] !== undefined ? _data["rating"] : <any>null;
            this.language = _data["language"] !== undefined ? _data["language"] : <any>null;
            this.nation = _data["nation"] !== undefined ? _data["nation"] : <any>null;
            if (Array.isArray(_data["genres"])) {
                this.genres = [] as any;
                for (let item of _data["genres"])
                    this.genres!.push(item);
            }
            else {
                this.genres = <any>null;
            }
            this.complete = _data["complete"] !== undefined ? _data["complete"] : <any>null;
            this.isTemporary = _data["isTemporary"] !== undefined ? _data["isTemporary"] : <any>null;
            if (Array.isArray(_data["tracks"])) {
                this.tracks = [] as any;
                for (let item of _data["tracks"])
                    this.tracks!.push(MusicModel.fromJS(item, _mappings));
            }
            else {
                this.tracks = <any>null;
            }
        }
    }

    static fromJS(data: any, _mappings?: any): PlaylistModel  {
        data = typeof data === 'object' ? data : {};
        return createInstance<PlaylistModel>(data, _mappings, PlaylistModel)!;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["author"] = this.author !== undefined ? this.author : <any>null;
        data["image"] = this.image !== undefined ? this.image : <any>null;
        data["rating"] = this.rating !== undefined ? this.rating : <any>null;
        data["language"] = this.language !== undefined ? this.language : <any>null;
        data["nation"] = this.nation !== undefined ? this.nation : <any>null;
        if (Array.isArray(this.genres)) {
            data["genres"] = [];
            for (let item of this.genres)
                data["genres"].push(item);
        }
        data["complete"] = this.complete !== undefined ? this.complete : <any>null;
        data["isTemporary"] = this.isTemporary !== undefined ? this.isTemporary : <any>null;
        if (Array.isArray(this.tracks)) {
            data["tracks"] = [];
            for (let item of this.tracks)
                data["tracks"].push(item.toJSON());
        }
        return data;
    }

    clone(): PlaylistModel {
        const json = this.toJSON();
        let result = new PlaylistModel();
        result.init(json);
        return result;
    }
}

export interface IPlaylistModel {
    id: string;
    name: string;
    author: string | null;
    image: string | null;
    rating: number;
    language: Language;
    nation: Language;
    genres: MusicGenre[];
    complete: boolean;
    isTemporary: boolean;
    tracks: MusicModel[];
}

export class UpdateRequestOfPlaylistModel implements IUpdateRequestOfPlaylistModel {
    oldModel!: PlaylistModel | null;
    newModel!: PlaylistModel | null;

    constructor(data?: Partial<IUpdateRequestOfPlaylistModel>) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property) && this.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }

    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.oldModel = _data["oldModel"] ? PlaylistModel.fromJS(_data["oldModel"], _mappings) : <any>null;
            this.newModel = _data["newModel"] ? PlaylistModel.fromJS(_data["newModel"], _mappings) : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): UpdateRequestOfPlaylistModel  {
        data = typeof data === 'object' ? data : {};
        return createInstance<UpdateRequestOfPlaylistModel>(data, _mappings, UpdateRequestOfPlaylistModel)!;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["oldModel"] = this.oldModel ? this.oldModel.toJSON() : <any>null;
        data["newModel"] = this.newModel ? this.newModel.toJSON() : <any>null;
        return data;
    }

    clone(): UpdateRequestOfPlaylistModel {
        const json = this.toJSON();
        let result = new UpdateRequestOfPlaylistModel();
        result.init(json);
        return result;
    }
}

export interface IUpdateRequestOfPlaylistModel {
    oldModel: PlaylistModel | null;
    newModel: PlaylistModel | null;
}

export class RecipeModelBase implements IRecipeModelBase {
    id!: string;
    title!: string;
    description!: string;
    image!: FoodImageModel;
    difficulty!: number;
    rating!: number;
    deleted!: boolean;
    type!: string | null;
    tags!: FoodTagModel[];

    protected _discriminator: string;

    constructor(data?: Partial<IRecipeModelBase>) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property) && this.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }

        if (!data) {
            this.image = new FoodImageModel();
            this.tags = [];
        }
        this._discriminator = "RecipeModelBase";
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.title = _data["title"] !== undefined ? _data["title"] : <any>null;
            this.description = _data["description"] !== undefined ? _data["description"] : <any>null;
            this.image = _data["image"] ? FoodImageModel.fromJS(_data["image"], _mappings) : new FoodImageModel();
            this.difficulty = _data["difficulty"] !== undefined ? _data["difficulty"] : <any>null;
            this.rating = _data["rating"] !== undefined ? _data["rating"] : <any>null;
            this.deleted = _data["deleted"] !== undefined ? _data["deleted"] : <any>null;
            this.type = _data["type"] !== undefined ? _data["type"] : <any>null;
            if (Array.isArray(_data["tags"])) {
                this.tags = [] as any;
                for (let item of _data["tags"])
                    this.tags!.push(FoodTagModel.fromJS(item, _mappings));
            }
            else {
                this.tags = <any>null;
            }
        }
    }

    static fromJS(data: any, _mappings?: any): RecipeModelBase  {
        data = typeof data === 'object' ? data : {};
        if (data["Type"] === "RecipeModel")
            return createInstance<RecipeModel>(data, _mappings, RecipeModel)!;
        if (data["Type"] === "FoodModel")
            return createInstance<FoodModel>(data, _mappings, FoodModel)!;
        return createInstance<RecipeModelBase>(data, _mappings, RecipeModelBase)!;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Type"] = this._discriminator;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["title"] = this.title !== undefined ? this.title : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        data["image"] = this.image ? this.image.toJSON() : <any>null;
        data["difficulty"] = this.difficulty !== undefined ? this.difficulty : <any>null;
        data["rating"] = this.rating !== undefined ? this.rating : <any>null;
        data["deleted"] = this.deleted !== undefined ? this.deleted : <any>null;
        data["type"] = this.type !== undefined ? this.type : <any>null;
        if (Array.isArray(this.tags)) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item.toJSON());
        }
        return data;
    }

    clone(): RecipeModelBase {
        const json = this.toJSON();
        let result = new RecipeModelBase();
        result.init(json);
        return result;
    }
}

export interface IRecipeModelBase {
    id: string;
    title: string;
    description: string;
    image: FoodImageModel;
    difficulty: number;
    rating: number;
    deleted: boolean;
    type: string | null;
    tags: FoodTagModel[];
}

export class FoodImageModel implements IFoodImageModel {
    recipeId!: string;
    mimeType!: string | null;
    imageData!: string | null;
    thumbData!: string | null;

    constructor(data?: Partial<IFoodImageModel>) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property) && this.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }

    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.recipeId = _data["recipeId"] !== undefined ? _data["recipeId"] : <any>null;
            this.mimeType = _data["mimeType"] !== undefined ? _data["mimeType"] : <any>null;
            this.imageData = _data["imageData"] !== undefined ? _data["imageData"] : <any>null;
            this.thumbData = _data["thumbData"] !== undefined ? _data["thumbData"] : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): FoodImageModel  {
        data = typeof data === 'object' ? data : {};
        return createInstance<FoodImageModel>(data, _mappings, FoodImageModel)!;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["recipeId"] = this.recipeId !== undefined ? this.recipeId : <any>null;
        data["mimeType"] = this.mimeType !== undefined ? this.mimeType : <any>null;
        data["imageData"] = this.imageData !== undefined ? this.imageData : <any>null;
        data["thumbData"] = this.thumbData !== undefined ? this.thumbData : <any>null;
        return data;
    }

    clone(): FoodImageModel {
        const json = this.toJSON();
        let result = new FoodImageModel();
        result.init(json);
        return result;
    }
}

export interface IFoodImageModel {
    recipeId: string;
    mimeType: string | null;
    imageData: string | null;
    thumbData: string | null;
}

export class FoodTagModel implements IFoodTagModel {
    recipeId!: string | null;
    key!: string;
    value!: string;

    constructor(data?: Partial<IFoodTagModel>) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property) && this.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }

    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.recipeId = _data["recipeId"] !== undefined ? _data["recipeId"] : <any>null;
            this.key = _data["key"] !== undefined ? _data["key"] : <any>null;
            this.value = _data["value"] !== undefined ? _data["value"] : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): FoodTagModel  {
        data = typeof data === 'object' ? data : {};
        return createInstance<FoodTagModel>(data, _mappings, FoodTagModel)!;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["recipeId"] = this.recipeId !== undefined ? this.recipeId : <any>null;
        data["key"] = this.key !== undefined ? this.key : <any>null;
        data["value"] = this.value !== undefined ? this.value : <any>null;
        return data;
    }

    clone(): FoodTagModel {
        const json = this.toJSON();
        let result = new FoodTagModel();
        result.init(json);
        return result;
    }
}

export interface IFoodTagModel {
    recipeId: string | null;
    key: string;
    value: string;
}

export class FoodModel extends RecipeModelBase implements IFoodModel {

    constructor(data?: Partial<IFoodModel>) {
        super(data);
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property) && this.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }

        this._discriminator = "FoodModel";
    }

    init(_data?: any, _mappings?: any) {
        super.init(_data);
    }

    static fromJS(data: any, _mappings?: any): FoodModel  {
        data = typeof data === 'object' ? data : {};
        return createInstance<FoodModel>(data, _mappings, FoodModel)!;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }

    clone(): FoodModel {
        const json = this.toJSON();
        let result = new FoodModel();
        result.init(json);
        return result;
    }
}

export interface IFoodModel extends IRecipeModelBase {
}

export class RecipeModel extends RecipeModelBase implements IRecipeModel {
    preparationTime!: string;
    cookingTime!: string;
    totalTime!: string;
    formattedText!: string | null;
    ingredients!: RecipeIngredientMappingModel[];
    cookware!: RecipeCookwareMappingModel[];
    ingredientNames!: string[];
    ingredientCategories!: IngredientCategory[];
    cookwareNames!: string[];

    constructor(data?: Partial<IRecipeModel>) {
        super(data);
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property) && this.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }

        if (!data) {
            this.ingredients = [];
            this.cookware = [];
            this.ingredientNames = [];
            this.ingredientCategories = [];
            this.cookwareNames = [];
        }
        this._discriminator = "RecipeModel";
    }

    init(_data?: any, _mappings?: any) {
        super.init(_data);
        if (_data) {
            this.preparationTime = _data["preparationTime"] !== undefined ? _data["preparationTime"] : <any>null;
            this.cookingTime = _data["cookingTime"] !== undefined ? _data["cookingTime"] : <any>null;
            this.totalTime = _data["totalTime"] !== undefined ? _data["totalTime"] : <any>null;
            this.formattedText = _data["formattedText"] !== undefined ? _data["formattedText"] : <any>null;
            if (Array.isArray(_data["ingredients"])) {
                this.ingredients = [] as any;
                for (let item of _data["ingredients"])
                    this.ingredients!.push(RecipeIngredientMappingModel.fromJS(item, _mappings));
            }
            else {
                this.ingredients = <any>null;
            }
            if (Array.isArray(_data["cookware"])) {
                this.cookware = [] as any;
                for (let item of _data["cookware"])
                    this.cookware!.push(RecipeCookwareMappingModel.fromJS(item, _mappings));
            }
            else {
                this.cookware = <any>null;
            }
            if (Array.isArray(_data["ingredientNames"])) {
                this.ingredientNames = [] as any;
                for (let item of _data["ingredientNames"])
                    this.ingredientNames!.push(item);
            }
            else {
                this.ingredientNames = <any>null;
            }
            if (Array.isArray(_data["ingredientCategories"])) {
                this.ingredientCategories = [] as any;
                for (let item of _data["ingredientCategories"])
                    this.ingredientCategories!.push(item);
            }
            else {
                this.ingredientCategories = <any>null;
            }
            if (Array.isArray(_data["cookwareNames"])) {
                this.cookwareNames = [] as any;
                for (let item of _data["cookwareNames"])
                    this.cookwareNames!.push(item);
            }
            else {
                this.cookwareNames = <any>null;
            }
        }
    }

    static fromJS(data: any, _mappings?: any): RecipeModel  {
        data = typeof data === 'object' ? data : {};
        return createInstance<RecipeModel>(data, _mappings, RecipeModel)!;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["preparationTime"] = this.preparationTime !== undefined ? this.preparationTime : <any>null;
        data["cookingTime"] = this.cookingTime !== undefined ? this.cookingTime : <any>null;
        data["totalTime"] = this.totalTime !== undefined ? this.totalTime : <any>null;
        data["formattedText"] = this.formattedText !== undefined ? this.formattedText : <any>null;
        if (Array.isArray(this.ingredients)) {
            data["ingredients"] = [];
            for (let item of this.ingredients)
                data["ingredients"].push(item.toJSON());
        }
        if (Array.isArray(this.cookware)) {
            data["cookware"] = [];
            for (let item of this.cookware)
                data["cookware"].push(item.toJSON());
        }
        if (Array.isArray(this.ingredientNames)) {
            data["ingredientNames"] = [];
            for (let item of this.ingredientNames)
                data["ingredientNames"].push(item);
        }
        if (Array.isArray(this.ingredientCategories)) {
            data["ingredientCategories"] = [];
            for (let item of this.ingredientCategories)
                data["ingredientCategories"].push(item);
        }
        if (Array.isArray(this.cookwareNames)) {
            data["cookwareNames"] = [];
            for (let item of this.cookwareNames)
                data["cookwareNames"].push(item);
        }
        super.toJSON(data);
        return data;
    }

    clone(): RecipeModel {
        const json = this.toJSON();
        let result = new RecipeModel();
        result.init(json);
        return result;
    }
}

export interface IRecipeModel extends IRecipeModelBase {
    preparationTime: string;
    cookingTime: string;
    totalTime: string;
    formattedText: string | null;
    ingredients: RecipeIngredientMappingModel[];
    cookware: RecipeCookwareMappingModel[];
    ingredientNames: string[];
    ingredientCategories: IngredientCategory[];
    cookwareNames: string[];
}

export class RecipeIngredientMappingModel implements IRecipeIngredientMappingModel {
    id!: string | null;
    recipeId!: string | null;
    ingredientName!: string;
    description!: string | null;
    groupName!: string | null;
    unit!: MeasurementUnit;
    amount!: number;
    order!: number;
    ingredient!: IngredientModel | null;

    constructor(data?: Partial<IRecipeIngredientMappingModel>) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property) && this.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }

        if (!data) {
            this.unit = new MeasurementUnit();
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.recipeId = _data["recipeId"] !== undefined ? _data["recipeId"] : <any>null;
            this.ingredientName = _data["ingredientName"] !== undefined ? _data["ingredientName"] : <any>null;
            this.description = _data["description"] !== undefined ? _data["description"] : <any>null;
            this.groupName = _data["groupName"] !== undefined ? _data["groupName"] : <any>null;
            this.unit = _data["unit"] ? MeasurementUnit.fromJS(_data["unit"], _mappings) : new MeasurementUnit();
            this.amount = _data["amount"] !== undefined ? _data["amount"] : <any>null;
            this.order = _data["order"] !== undefined ? _data["order"] : <any>null;
            this.ingredient = _data["ingredient"] ? IngredientModel.fromJS(_data["ingredient"], _mappings) : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): RecipeIngredientMappingModel  {
        data = typeof data === 'object' ? data : {};
        return createInstance<RecipeIngredientMappingModel>(data, _mappings, RecipeIngredientMappingModel)!;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["recipeId"] = this.recipeId !== undefined ? this.recipeId : <any>null;
        data["ingredientName"] = this.ingredientName !== undefined ? this.ingredientName : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        data["groupName"] = this.groupName !== undefined ? this.groupName : <any>null;
        data["unit"] = this.unit ? this.unit.toJSON() : <any>null;
        data["amount"] = this.amount !== undefined ? this.amount : <any>null;
        data["order"] = this.order !== undefined ? this.order : <any>null;
        data["ingredient"] = this.ingredient ? this.ingredient.toJSON() : <any>null;
        return data;
    }

    clone(): RecipeIngredientMappingModel {
        const json = this.toJSON();
        let result = new RecipeIngredientMappingModel();
        result.init(json);
        return result;
    }
}

export interface IRecipeIngredientMappingModel {
    id: string | null;
    recipeId: string | null;
    ingredientName: string;
    description: string | null;
    groupName: string | null;
    unit: MeasurementUnit;
    amount: number;
    order: number;
    ingredient: IngredientModel | null;
}

export class MeasurementUnit implements IMeasurementUnit {
    name!: string;
    shortName!: string;
    multiplier!: number;
    measurement!: Measurement;

    constructor(data?: Partial<IMeasurementUnit>) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property) && this.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }

    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.shortName = _data["shortName"] !== undefined ? _data["shortName"] : <any>null;
            this.multiplier = _data["multiplier"] !== undefined ? _data["multiplier"] : <any>null;
            this.measurement = _data["measurement"] !== undefined ? _data["measurement"] : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): MeasurementUnit  {
        data = typeof data === 'object' ? data : {};
        return createInstance<MeasurementUnit>(data, _mappings, MeasurementUnit)!;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["shortName"] = this.shortName !== undefined ? this.shortName : <any>null;
        data["multiplier"] = this.multiplier !== undefined ? this.multiplier : <any>null;
        data["measurement"] = this.measurement !== undefined ? this.measurement : <any>null;
        return data;
    }

    clone(): MeasurementUnit {
        const json = this.toJSON();
        let result = new MeasurementUnit();
        result.init(json);
        return result;
    }
}

export interface IMeasurementUnit {
    name: string;
    shortName: string;
    multiplier: number;
    measurement: Measurement;
}

export enum Measurement {
    Mass = "Mass",
    Volume = "Volume",
    Size = "Size",
    Pinch = "Pinch",
    Piece = "Piece",
    Unitless = "Unitless",
}

export class IngredientModel implements IIngredientModel {
    ingredientName!: string;
    lowestKnownPrice!: string;
    nation!: Language;
    category!: IngredientCategory;
    isFluid!: boolean;

    constructor(data?: Partial<IIngredientModel>) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property) && this.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }

    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.ingredientName = _data["ingredientName"] !== undefined ? _data["ingredientName"] : <any>null;
            this.lowestKnownPrice = _data["lowestKnownPrice"] !== undefined ? _data["lowestKnownPrice"] : <any>null;
            this.nation = _data["nation"] !== undefined ? _data["nation"] : <any>null;
            this.category = _data["category"] !== undefined ? _data["category"] : <any>null;
            this.isFluid = _data["isFluid"] !== undefined ? _data["isFluid"] : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): IngredientModel  {
        data = typeof data === 'object' ? data : {};
        return createInstance<IngredientModel>(data, _mappings, IngredientModel)!;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ingredientName"] = this.ingredientName !== undefined ? this.ingredientName : <any>null;
        data["lowestKnownPrice"] = this.lowestKnownPrice !== undefined ? this.lowestKnownPrice : <any>null;
        data["nation"] = this.nation !== undefined ? this.nation : <any>null;
        data["category"] = this.category !== undefined ? this.category : <any>null;
        data["isFluid"] = this.isFluid !== undefined ? this.isFluid : <any>null;
        return data;
    }

    clone(): IngredientModel {
        const json = this.toJSON();
        let result = new IngredientModel();
        result.init(json);
        return result;
    }
}

export interface IIngredientModel {
    ingredientName: string;
    lowestKnownPrice: string;
    nation: Language;
    category: IngredientCategory;
    isFluid: boolean;
}

export enum IngredientCategory {
    Meat = "Meat",
    Noodles = "Noodles",
    Rice = "Rice",
    Bread = "Bread",
    Fish = "Fish",
    Vegetables = "Vegetables",
    Fruits = "Fruits",
    Dairy = "Dairy",
    Eggs = "Eggs",
    Nuts = "Nuts",
    Drinks = "Drinks",
    Condiments = "Condiments",
    Oil = "Oil",
    Miscellaneous = "Miscellaneous",
}

export class RecipeCookwareMappingModel implements IRecipeCookwareMappingModel {
    id!: string | null;
    recipeId!: string;
    name!: string;

    constructor(data?: Partial<IRecipeCookwareMappingModel>) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property) && this.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }

    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.recipeId = _data["recipeId"] !== undefined ? _data["recipeId"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): RecipeCookwareMappingModel  {
        data = typeof data === 'object' ? data : {};
        return createInstance<RecipeCookwareMappingModel>(data, _mappings, RecipeCookwareMappingModel)!;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["recipeId"] = this.recipeId !== undefined ? this.recipeId : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        return data;
    }

    clone(): RecipeCookwareMappingModel {
        const json = this.toJSON();
        let result = new RecipeCookwareMappingModel();
        result.init(json);
        return result;
    }
}

export interface IRecipeCookwareMappingModel {
    id: string | null;
    recipeId: string;
    name: string;
}

function jsonParse(json: any, reviver?: any) {
    json = JSON.parse(json, reviver);

    var byid: any = {};
    var refs: any = [];
    json = (function recurse(obj: any, prop?: any, parent?: any) {
        if (typeof obj !== 'object' || !obj)
            return obj;
        
        if ("$ref" in obj) {
            let ref = obj.$ref;
            if (ref in byid)
                return byid[ref];
            refs.push([parent, prop, ref]);
            return undefined;
        } else if ("$id" in obj) {
            let id = obj.$id;
            delete obj.$id;
            if ("$values" in obj)
                obj = obj.$values;
            byid[id] = obj;
        }
        
        if (Array.isArray(obj)) {
            obj = obj.map((v, i) => recurse(v, i, obj));
        } else {
            for (var p in obj) {
                if (obj.hasOwnProperty(p) && obj[p] && typeof obj[p] === 'object')
                    obj[p] = recurse(obj[p], p, obj);
            }
        }

        return obj;
    })(json);

    for (let i = 0; i < refs.length; i++) {
        const ref = refs[i];
        ref[0][ref[1]] = byid[ref[2]];
    }

    return json;
}

function createInstance<T>(data: any, mappings: any, type: any): T | null {
  if (!mappings)
    mappings = [];
  if (!data)
    return null;

  const mappingIndexName = "__mappingIndex";
  if (data[mappingIndexName])
    return <T>mappings[data[mappingIndexName]].target;

  data[mappingIndexName] = mappings.length;

  let result: any = new type();
  mappings.push({ source: data, target: result });
  result.init(data, mappings);
  return result;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class SwaggerException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new SwaggerException(message, status, response, headers, null);
}